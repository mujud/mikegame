{"version":3,"sources":["components/Board.tsx","util/assert.ts","components/StoreContext.ts","model/MazeData.ts","model/Coordinates.ts","components/Box.tsx","model/collisionDetection.ts","model/eatEnergizer.ts","model/detectCollisions.ts","model/pacManDyingPhase.ts","pages/GamePage/components/head.png","pages/GamePage/components/mouth.png","pages/GamePage/components/MikeSprite.tsx","pages/GamePage/components/MikeSpriteEnd.tsx","pages/GamePage/components/PacManView.tsx","pages/GamePage/components/ExtraLives.tsx","pages/GamePage/components/Message.tsx","pages/GamePage/components/GameOver.tsx","pages/WayFindingPage/WayPoint.tsx","model/getDirectionFromTileToTile.ts","pages/WayFindingPage/WayPoints.tsx","components/Sprite.tsx","pages/GamePage/components/Target.tsx","pages/GamePage/components/GhostsView.tsx","pages/GamePage/components/MazeView.tsx","pages/GamePage/components/PillsView.tsx","pages/GamePage/components/wine.png","pages/GamePage/components/Score.tsx","components/Spacer.tsx","model/Types.ts","model/Vector.ts","model/Ways.ts","model/getTileDistance.ts","model/chooseNewTargetTile.ts","model/chooseNextTile.ts","model/updateGhostStatePhase.ts","model/updateGhosts.ts","model/movePacManBy.ts","model/updatePacMan.ts","model/onAnimationFrame.ts","model/updateExternalTimeStamp.ts","model/updateGameTimestamp.ts","model/updateEnergizerTimer.ts","model/useGameLoop.ts","model/useAnimationLoop.ts","pages/GamePage/GamePage.tsx","pages/GamePage/components/useKeyboardActions.ts","components/Grid.tsx","pages/MazePage/MazePage.tsx","model/changeDirectionToOpposite.ts","model/findWayPoints.ts","model/GhostStateChart.ts","model/TimeoutTimer.ts","model/Ghost.ts","pages/SpritePage/SpritePage.tsx","pages/WayFindingPage/WayFindingPage.tsx","Routes.tsx","components/AppMenu.tsx","model/makeGhosts.ts","model/Maze.ts","model/PacManStateChart.ts","model/PacMan.ts","model/Game.ts","model/DebugState.ts","model/Store.ts","App.tsx","index.tsx"],"names":["Board","className","children","classNames","assert","condition","msg","Error","StoreContext","createContext","StoreProvider","Provider","useStore","store","useContext","useGame","game","BASIC_PILL_ID","getLayer","layerName","layer","MapData","layers","find","name","pillsLayer","waysLayer","MAZE_WIDTH_IN_TILES","width","MAZE_HEIGHT_IN_TILES","height","getTileMatrix","data","tileMatrix","Array","dataIndex","ty","tx","tileId","getPillsMatrix","waysMatrix","SCALE_FACTOR","SCREEN_TILE_SIZE","SPRITE_TILE_SIZE","SCREEN_TILE_CENTER","SCREEN_TILE_CENTER_VECTOR","x","y","MAZE_WIDTH_IN_SCREEN_COORDINATES","MAZE_HEIGHT_IN_SCREEN_COORDINATES","MAZE_DIMENSIONS_IN_TILES","isTxValid","isTyValid","isValidTileCoordinates","tile","assertValidTileCoordinates","screenFromTileCoordinate","tileCoordinate","tileFromScreenCoordinate","screenCoordinate","Math","floor","screenFromTile","tileFromScreen","screen","addCoordinatesAndVector","coordinates","vector","rectangleContainsTile","tileRectangle","tile1","tile2","wrapTileToBounds","bounds","Box","rect","color","style","position","left","top","backgroundColor","zIndex","collide","rect1","rect2","eatEnergizer","action","score","killedGhosts","pacMan","send","ghosts","getPillHitBox","pill","PILL_BOX_HIT_BOX_WIDTH","getPacManHitBox","PAC_MAN_HIT_BOX_WIDTH","PAC_MAN_HIT_BOX_HEIGHT","getGhostHitBox","GHOST_HIT_BOX_WIDTH","GHOST_HIT_BOX_HEIGHT","eatPillLayerObject","maze","pills","eatPill","console","error","ghostCollidesWithPacMan","ghost","detectCollisions","dead","pillTile","tileCoordinates","pillHitBox","pacManHitBox","screenCoordinates","detectPacManEatingPill","ghostHitBox","detectGhostCollisions","PacManDyingPhases","from","keys","TotalPacManDyingAnimationLength","PacManDyingPhaseLength","MikeSprite","pacManAnimationPhase","direction","directionMultiplier","transform","src","head","transformOrigin","mouth","MikeSpriteEnd","dyingPacManAnimationPhase","filter","PacManAnimationPhases","PacManView","observer","alive","gameViewOptions","debugState","getPacManAnimationPhase","dyingPhase","timeSinceDeath","PacManDyingPhaseCount","getPacManDyingPhase","hitBox","PAC_MAN_WIDTH","PAC_MAN_HEIGHT","step","round","timestamp","PacManSprite","DyingPacManSprite","PacManHitBox","ExtraLives","Layout","times","extraLivesLeft","n","styled","div","Message","text","MessageStyled","span","GameOver","gameOver","POINTS","DirectionToAngle","DOWN","LEFT","UP","RIGHT","WayPoint","angle","SvgStyled","viewBox","points","fill","stroke","strokeWidth","svg","TUNNEL_X_RIGHT","getDirectionFromTileToTile","tileFrom","tileTo","isEqual","WayPoints","wayPoints","map","wayPoint","index","getDirection","length","indexToUse","fromTile","toTile","scale","Sprite","spriteName","Target","version","d","GhostsGameView","ghostViewOptions","GhostsView","DefaultGhostViewOptions","DefaultGameViewOptions","GhostCompositeView","ghostNumber","target","GhostView","colorCode","targetTile","animationPhase","state","frightenedGhostTime","ghostAnimationPhase","GHOST_WIDTH","GHOST_HEIGHT","GhostSprite","phase","DeadGhostSprite","FrightenedGhostSprite","GhostHitBox","MazeView","BasicPillView","BasicPillHitBox","PillView","log","background","PillsView","memo","_","displayName","Score","SIZE_MAPPING","small","medium","large","mappedSize","size","VSpace","Directions","assertValidDirection","includes","multiplyVector","factor","BOX_TILE_COORDINATES","BOX_SPACE_TILE_COORDINATES","isWayFreeAt","isTileCenter","DIRECTION_TO_VECTOR","directionToVector","distance","moveFromTile","steps","newTile","DIRECTION_TO_OPPOSITE_DIRECTION","isWayFreeInDirection","stepSize","nextTile","getNextTile","DIRECTION_TO_TILE_VECTOR","scaledVector","movedTile","getTileDistance","neighbourTile","dx","abs","dy","sqrt","pow","TILE_FOR_LEAVING_THE_BOX","TILE_FOR_RETURNING_TO_BOX","SCATTER_TILE_FOR_GHOST_0","chooseInScatterMode","isInsideBoxWalls","chooseForGhost2InChaseState","to","intermediateTile","chooseGhost2IntermediateTile","blinky","vectorToBlinky","rotatedVector","twoTilesAhead","choseInChaseMode","chooseForGhost0InChaseState","fourTilesAhead","chooseForGhost1InChaseState","chooseForGhost3InChaseState","chooseInFrightenedMode","chooseSomeRandomMovement","candidateDirections","max","newDirection","random","chooseInDeadMode","chooseNextTile","currentTile","currentDirection","boxDoorIsOpen","toJS","bestNextTile","chooseBestNextTile","anyNextTile","chooseAnyNextTile","JSON","stringify","candidates","possibleNextTile","distanceToTarget","push","bestCandidate","minBy","neighbourTileInCurrentDirection","isWayFreeForGhostAt","updateGhostStatePhaseTime","statePhaseTimer","advance","lastFrameLength","updateGhostStatePhase","atTileCenter","isTimedOut","setDuration","getStatePhaseLength","restart","updateGhost","ghostPaused","updateDeadWaitingTimeInBoxLeft","routeAndMoveGhost","deadWaitingTimeInBoxLeft","reRouteGhost","moveGhost","chooseNewTargetTile","updateDirection","updateSpeed","getNewDirection","newSpeedFactor","getNewSpeedFactor","speedFactor","canPassThroughBoxDoor","getGhostMovementVector","moveGhostBy","speed","movePacManBy","updateLivingPacMan","nextDirection","movePacMan","delta","directionAsVector","updateDeadPacMan","revivePacMan","onAnimationFrame","externalTimeStamp","updateExternalTimestamp","gamePaused","frameCount","updateGameTimestamp","energizerTimer","updateEnergizerTimer","updatePacMan","updateGhosts","useGameLoop","animationStep","requestRef","useRef","animate","current","requestAnimationFrame","useEffect","cancelAnimationFrame","useAnimationLoop","GamePage","resetGame","onKeyDown","useCallback","event","pressedKey","key","document","addEventListener","removeEventListener","useKeyboardActions","data-testid","ScoreArea","justify","EmptyArea","BoardArea","onClick","GridWithHoverCoordinates","useState","setCoordinates","pillsMatrix","onHover","ROWS","Grid","gridTemplateColumns","gridTemplateRows","rowIndex","columnIndex","onMouseEnter","onMouseLeave","MazePage","flex","RelativeAbsoluteLayout","changeDirectionToOpposite","findWayPoints","origin","destination","way","workingDirection","some","INITIAL_GHOST_STATE","GhostStateChart","Machine","id","initial","on","RESET","states","chase","ENERGIZER_EATEN","PHASE_END","actions","COLLISION_WITH_PAC_MAN","scatter","frightened","ENERGIZER_TIMED_OUT","REVIVED","TimeoutTimer","bound","duration","onTimedOut","this","running","timeSpent","timePassed","stop","start","observable","computed","GhostNumbers","GhostAnimationPhases","FrightenedGhostTimes","KILL_GHOST_SCORE","Ghost","ref","stateChart","eventHandler","extended","withConfig","onScatterToChase","onChaseToScatter","onDead","interpret","makeGhostStateChart","initialWaitingTimeInBox","onTransition","handleStateTransition","changed","stateChartState","stateChanges","value","matches","timeLeft","frightenedAboutToEnd","isOutsideBoxSpace","SpritePage","phaseCounter","setPhaseCounter","directionIndex","setDirectionIndex","pacManPhase","ghostPhase","timerId","setInterval","clearInterval","dyingPacManPhase","WayFindingPage","localStore","useLocalStore","setOrigin","setDestination","shiftKey","Routes","path","exact","AppMenu","location","useLocation","history","useHistory","selectedKey","pathname","MenuStyled","mode","toString","selectedKeys","Item","Menu","resetGhosts","setTileCoordinates","resetGhost","Maze","INITIAL_PACMAN_STATE","PacManStateChart","eating","COLLISION_WITH_GHOST","chasing","entry","PacMan","onChasing","makePacManStateChart","handleTransition","diedAtTimestamp","resetPacMan","Game","handleEnergizerTimedOut","makeGhosts","DebugState","somePlaceholder","Store","readyGameForPlay","App","Router","BrowserRouter","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.453e32c1.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Board.css';\r\nimport classNames from 'classnames';\r\n\r\nexport const Board: React.FC<{ className?: string }> = ({\r\n  className,\r\n  children,\r\n}) => <div className={classNames('Board', className)}>{children}</div>;\r\n","export function assert(condition: any, msg?: string): asserts condition {\r\n  if (!condition) {\r\n    throw new Error(`Assertion error ${msg ?? ''}`);\r\n  }\r\n}\r\n","import { createContext, useContext } from 'react';\r\nimport { Game } from '../model/Game';\r\nimport { assert } from '../util/assert';\r\nimport { Store } from '../model/Store';\r\n\r\nexport const StoreContext = createContext<Store | null>(null);\r\n\r\nexport const StoreProvider = StoreContext.Provider;\r\n\r\nexport const useStore = (): Store => {\r\n  const store = useContext(StoreContext);\r\n  assert(store, 'Store not provided - use <StoreProvider>');\r\n  return store;\r\n};\r\n\r\nexport const useGame = (): Game => {\r\n  const store = useStore();\r\n  return store.game;\r\n};\r\n","import MapData from '../mapData/pacman6.json';\r\n\r\nexport type TileId = number;\r\n\r\nexport const EMPTY_TILE_ID: TileId = 0;\r\nexport const BASIC_PILL_ID: TileId = 3533;\r\nexport const ENERGIZER_ID: TileId = 3589;\r\n\r\nexport const WAY_FREE_ID: TileId = 5240;\r\nexport const BOX_DOOR_ID: TileId = 5241;\r\n\r\nexport type TileMatrix = TileId[][];\r\n\r\ninterface Layer {\r\n  data: number[];\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nconst getLayer = (layerName: string): Layer => {\r\n  const layer = MapData.layers.find(layer => layer.name === layerName);\r\n  if (!layer) {\r\n    throw new Error(`${layerName} layer not found`);\r\n  }\r\n  return layer;\r\n};\r\n\r\nconst pillsLayer: Layer = getLayer('Pills');\r\nconst waysLayer: Layer = getLayer('Ways');\r\n\r\nexport const MAZE_WIDTH_IN_TILES = pillsLayer.width;\r\nexport const MAZE_HEIGHT_IN_TILES = pillsLayer.height;\r\n\r\nexport const getTileMatrix = (data: TileId[]): TileMatrix => {\r\n  const tileMatrix: number[][] = Array(MAZE_HEIGHT_IN_TILES);\r\n  let dataIndex = 0;\r\n  for (let ty = 0; ty < MAZE_HEIGHT_IN_TILES; ty++) {\r\n    tileMatrix[ty] = Array(MAZE_WIDTH_IN_TILES);\r\n    for (let tx = 0; tx < MAZE_WIDTH_IN_TILES; tx++) {\r\n      const tileId = data[dataIndex];\r\n      tileMatrix[ty][tx] = tileId;\r\n      dataIndex++;\r\n    }\r\n  }\r\n  return tileMatrix;\r\n};\r\n\r\nexport const getPillsMatrix = (): TileMatrix => getTileMatrix(pillsLayer.data);\r\n\r\nexport const waysMatrix: TileMatrix = getTileMatrix(waysLayer.data);\r\n","import { MAZE_WIDTH_IN_TILES, MAZE_HEIGHT_IN_TILES } from './MazeData';\r\nimport { assert } from '../util/assert';\r\nimport { Vector } from './Vector';\r\n\r\nexport type Coordinate = number;\r\n\r\nexport type TileCoordinate = Coordinate;\r\nexport type ScreenCoordinate = Coordinate;\r\n\r\nexport interface TileCoordinates {\r\n  x: TileCoordinate;\r\n  y: TileCoordinate;\r\n}\r\n\r\nexport interface ScreenCoordinates {\r\n  x: ScreenCoordinate;\r\n  y: ScreenCoordinate;\r\n}\r\n\r\nexport type Coordinates = TileCoordinates | ScreenCoordinates;\r\n\r\nexport interface TileRectangle {\r\n  tile1: TileCoordinates;\r\n  tile2: TileCoordinates;\r\n}\r\n\r\nexport const SCALE_FACTOR = 2.5;\r\nexport const SPRITE_TILE_SIZE = 8;\r\nexport const SCREEN_TILE_SIZE = SPRITE_TILE_SIZE * SCALE_FACTOR;\r\nexport const SCREEN_TILE_CENTER = SCREEN_TILE_SIZE / 2;\r\n\r\nexport const SCREEN_TILE_CENTER_VECTOR: Vector = {\r\n  x: SCREEN_TILE_CENTER,\r\n  y: SCREEN_TILE_CENTER,\r\n};\r\n\r\nexport const MAZE_WIDTH_IN_SCREEN_COORDINATES =\r\n  MAZE_WIDTH_IN_TILES * SCREEN_TILE_SIZE;\r\nexport const MAZE_HEIGHT_IN_SCREEN_COORDINATES =\r\n  MAZE_HEIGHT_IN_TILES * SCREEN_TILE_SIZE;\r\n\r\nexport const MAZE_DIMENSIONS_IN_TILES: TileCoordinates = {\r\n  x: MAZE_WIDTH_IN_TILES,\r\n  y: MAZE_HEIGHT_IN_TILES,\r\n};\r\n\r\nexport const isTxValid = (tx: TileCoordinate) =>\r\n  tx >= 0 && tx < MAZE_WIDTH_IN_TILES;\r\nexport const isTyValid = (ty: TileCoordinate) =>\r\n  ty >= 0 && ty < MAZE_HEIGHT_IN_TILES;\r\nexport const isValidTileCoordinates = (tile: TileCoordinates) =>\r\n  isTxValid(tile.x) && isTyValid(tile.y);\r\n\r\nexport const assertValidTx = (tx: TileCoordinate) => {\r\n  assert(isTxValid(tx), `Invalid t.x ${tx} width: ${MAZE_WIDTH_IN_TILES}`);\r\n};\r\n\r\nexport const assertValidTy = (ty: TileCoordinate) => {\r\n  assert(isTyValid(ty), `Invalid t.y ${ty} height: ${MAZE_HEIGHT_IN_TILES}`);\r\n};\r\n\r\nexport const assertValidTileCoordinates = (tile: TileCoordinates) => {\r\n  assertValidTx(tile.x);\r\n  assertValidTy(tile.y);\r\n};\r\n\r\nexport const screenFromTileCoordinate = (\r\n  tileCoordinate: TileCoordinate\r\n): ScreenCoordinate => tileCoordinate * SCREEN_TILE_SIZE;\r\n\r\nexport const tileFromScreenCoordinate = (\r\n  screenCoordinate: ScreenCoordinate\r\n): TileCoordinate => Math.floor(screenCoordinate / SCREEN_TILE_SIZE);\r\n\r\nexport const screenFromTile = (tile: TileCoordinates): ScreenCoordinates => ({\r\n  x: screenFromTileCoordinate(tile.x),\r\n  y: screenFromTileCoordinate(tile.y),\r\n});\r\n\r\nexport const tileFromScreen = (screen: ScreenCoordinates): TileCoordinates => ({\r\n  x: tileFromScreenCoordinate(screen.x),\r\n  y: tileFromScreenCoordinate(screen.y),\r\n});\r\n\r\nexport const getPointDifferenceAsVector = (\r\n  from: Coordinates,\r\n  to: Coordinates\r\n): Vector => ({\r\n  x: to.x - from.x,\r\n  y: to.y - from.y,\r\n});\r\n\r\nexport const addCoordinatesAndVector = (\r\n  coordinates: Coordinates,\r\n  vector: Vector\r\n): ScreenCoordinates => ({\r\n  x: coordinates.x + vector.x,\r\n  y: coordinates.y + vector.y,\r\n});\r\n\r\nexport const rectangleContainsTile = (\r\n  tileRectangle: TileRectangle,\r\n  tile: TileCoordinates\r\n): boolean =>\r\n  tile.x >= tileRectangle.tile1.x &&\r\n  tile.x <= tileRectangle.tile2.x &&\r\n  tile.y >= tileRectangle.tile1.y &&\r\n  tile.y <= tileRectangle.tile2.y;\r\n\r\nexport const wrapTileToBounds = (\r\n  tile: TileCoordinates,\r\n  bounds: TileCoordinates\r\n): TileCoordinates => {\r\n  const wrappedX = (tile.x + bounds.x) % bounds.x;\r\n  const wrappedY = (tile.y + bounds.y) % bounds.y;\r\n  return { x: wrappedX, y: wrappedY };\r\n};\r\n","import React, { FC } from 'react';\r\nimport { Rectangle } from '../model/Rectangle';\r\n\r\nexport const Box: FC<{ rect: Rectangle; color: string }> = ({\r\n  rect,\r\n  color,\r\n}) => (\r\n  <div\r\n    style={{\r\n      position: 'absolute',\r\n      left: rect.x,\r\n      top: rect.y,\r\n      width: rect.width,\r\n      height: rect.height,\r\n      backgroundColor: color,\r\n      zIndex: 1000,\r\n    }}\r\n  />\r\n);\r\n","import { Rectangle } from './Rectangle';\r\n\r\nexport const collide = (rect1: Rectangle, rect2: Rectangle): boolean => {\r\n  return (\r\n    rect1.x < rect2.x + rect2.width &&\r\n    rect1.x + rect1.width > rect2.x &&\r\n    rect1.y < rect2.y + rect2.height &&\r\n    rect1.y + rect1.height > rect2.y\r\n  );\r\n};\r\n","import { Game } from './Game';\r\nimport { action } from 'mobx';\r\n\r\nexport const ENERGIZER_POINTS = 30;\r\n\r\nexport const eatEnergizer = action((game: Game) => {\r\n  game.score += ENERGIZER_POINTS;\r\n  game.killedGhosts = 0;\r\n  game.pacMan.send('ENERGIZER_EATEN');\r\n  for (const ghost of game.ghosts) {\r\n    ghost.send('ENERGIZER_EATEN');\r\n  }\r\n});\r\n","import { collide } from './collisionDetection';\r\nimport {\r\n  SCALE_FACTOR,\r\n  ScreenCoordinates,\r\n  screenFromTile,\r\n  TileCoordinates,\r\n} from './Coordinates';\r\nimport { eatEnergizer } from './eatEnergizer';\r\nimport { Game } from './Game';\r\nimport { Ghost } from './Ghost';\r\nimport { BASIC_PILL_ID, EMPTY_TILE_ID, ENERGIZER_ID, TileId } from './MazeData';\r\nimport { Rectangle } from './Rectangle';\r\n\r\nconst PILL_BOX_HIT_BOX_WIDTH = 2;\r\nconst PILL_BOX_HIT_BOX_HEIGHT = 2;\r\n\r\nexport const getPillHitBox = (\r\n  tile: TileCoordinates,\r\n  pill: TileId\r\n): Rectangle => {\r\n  const screen = screenFromTile(tile);\r\n  return {\r\n    x: screen.x - PILL_BOX_HIT_BOX_WIDTH / 2,\r\n    y: screen.y - PILL_BOX_HIT_BOX_WIDTH / 2,\r\n    width: PILL_BOX_HIT_BOX_WIDTH,\r\n    height: PILL_BOX_HIT_BOX_HEIGHT,\r\n  };\r\n};\r\n\r\nconst PAC_MAN_HIT_BOX_WIDTH = 15;\r\nconst PAC_MAN_HIT_BOX_HEIGHT = 15;\r\n\r\nexport const getPacManHitBox = (screen: ScreenCoordinates): Rectangle => {\r\n  return {\r\n    x: screen.x - PAC_MAN_HIT_BOX_WIDTH / 2 + 1,\r\n    y: screen.y - PAC_MAN_HIT_BOX_HEIGHT / 2 + 2,\r\n    width: PAC_MAN_HIT_BOX_WIDTH,\r\n    height: PAC_MAN_HIT_BOX_HEIGHT,\r\n  };\r\n};\r\n\r\nconst GHOST_HIT_BOX_WIDTH = 10;\r\nconst GHOST_HIT_BOX_HEIGHT = 10;\r\n\r\nexport const getGhostHitBox = (screen: ScreenCoordinates): Rectangle => {\r\n  return {\r\n    x: screen.x - (GHOST_HIT_BOX_WIDTH * SCALE_FACTOR) / 2,\r\n    y: screen.y - (GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR) / 2,\r\n    width: GHOST_HIT_BOX_WIDTH * SCALE_FACTOR,\r\n    height: GHOST_HIT_BOX_HEIGHT * SCALE_FACTOR,\r\n  };\r\n};\r\n\r\nconst detectPacManEatingPill = (game: Game) => {\r\n  const pillTile = game.pacMan.tileCoordinates;\r\n  const pill: TileId = game.maze.pills[pillTile.y][pillTile.x];\r\n  if (pill === EMPTY_TILE_ID) {\r\n    return;\r\n  }\r\n\r\n  const pillHitBox: Rectangle = getPillHitBox(pillTile, pill);\r\n  const pacManHitBox: Rectangle = getPacManHitBox(\r\n    game.pacMan.screenCoordinates\r\n  );\r\n  if (collide(pacManHitBox, pillHitBox)) {\r\n    eatPillLayerObject(pillTile, game);\r\n  }\r\n};\r\n\r\nexport const BASIC_PILL_POINTS = 10;\r\n\r\nconst eatPillLayerObject = (tile: TileCoordinates, game: Game) => {\r\n  const tileId = game.maze.pills[tile.y][tile.x];\r\n  switch (tileId) {\r\n    case BASIC_PILL_ID:\r\n      eatPill(tile, game);\r\n      break;\r\n    case ENERGIZER_ID:\r\n      eatEnergizer(game);\r\n      break;\r\n    default:\r\n      console.error('Unknown pill layer tile id', tileId);\r\n      break;\r\n  }\r\n\r\n  game.maze.pills[tile.y][tile.x] = EMPTY_TILE_ID;\r\n};\r\n\r\nconst eatPill = (tile: TileCoordinates, game: Game) => {\r\n  game.score += BASIC_PILL_POINTS;\r\n};\r\n\r\nconst detectGhostCollisions = (game: Game) => {\r\n  const pacManHitBox: Rectangle = getPacManHitBox(\r\n    game.pacMan.screenCoordinates\r\n  );\r\n\r\n  for (const ghost of game.ghosts) {\r\n    if (ghost.dead) {\r\n      continue;\r\n    }\r\n\r\n    const ghostHitBox: Rectangle = getGhostHitBox(ghost.screenCoordinates);\r\n    if (collide(pacManHitBox, ghostHitBox)) {\r\n      ghostCollidesWithPacMan(ghost);\r\n    }\r\n  }\r\n};\r\n\r\nexport const ghostCollidesWithPacMan = (ghost: Ghost) => {\r\n  const game = ghost.game;\r\n  game.pacMan.send('COLLISION_WITH_GHOST');\r\n  ghost.send('COLLISION_WITH_PAC_MAN');\r\n};\r\n\r\nexport const detectCollisions = (game: Game) => {\r\n  if (game.pacMan.dead) {\r\n    return;\r\n  }\r\n\r\n  detectPacManEatingPill(game);\r\n  detectGhostCollisions(game);\r\n};\r\n","import { MilliSeconds } from './Types';\r\nimport { PacMan } from './PacMan';\r\n\r\nexport type PacManDyingPhase = number;\r\nexport const PacManDyingPhaseCount = 13;\r\nexport const PacManDyingPhases: PacManDyingPhase[] = Array.from(\r\n  Array(PacManDyingPhaseCount).keys()\r\n);\r\nexport const PacManDyingPhaseLength: MilliSeconds = 200;\r\nexport const TotalPacManDyingAnimationLength: MilliSeconds =\r\n  PacManDyingPhaseLength * PacManDyingPhaseCount;\r\n\r\nexport const getPacManDyingPhase = (pacMan: PacMan): PacManDyingPhase => {\r\n  let dyingPhase: number = Math.floor(\r\n    pacMan.timeSinceDeath / PacManDyingPhaseLength\r\n  );\r\n  if (dyingPhase >= PacManDyingPhaseCount) {\r\n    dyingPhase = PacManDyingPhaseCount - 1;\r\n  }\r\n  return dyingPhase as PacManDyingPhase;\r\n};\r\n","export default __webpack_public_path__ + \"static/media/head.ec59cc13.png\";","export default \"data:image/png;base64,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\"","import { CSSProperties, FC } from 'react';\r\nimport { Direction } from '../../../model/Types';\r\nimport { PacManAnimationPhase } from './PacManView';\r\nimport head from './head.png';\r\nimport mouth from './mouth.png';\r\nconst MikeSprite: FC<{\r\n  direction: Direction;\r\n  pacManAnimationPhase: PacManAnimationPhase;\r\n  x: number;\r\n  y: number;\r\n  style?: CSSProperties;\r\n}> = ({ pacManAnimationPhase, x, y, direction }) => {\r\n  const directionMultiplier =\r\n    direction === 'UP' ? -90 : direction === 'DOWN' ? 90 : 0;\r\n  return (\r\n    <div\r\n      style={{\r\n        height: '2rem',\r\n        width: '3rem',\r\n        position: 'absolute',\r\n        left: x,\r\n        top: y,\r\n        transform: `rotate(${directionMultiplier}deg) scaleX(${\r\n          direction === 'LEFT' ? -1 : 1\r\n        })`,\r\n      }}\r\n    >\r\n      <img\r\n        style={{\r\n          width: '1.5rem',\r\n          position: 'absolute',\r\n          top: '0rem',\r\n          left: '0rem',\r\n        }}\r\n        src={head}\r\n      />\r\n      <img\r\n        style={{\r\n          width: '1rem',\r\n          position: 'absolute',\r\n          top: '1.3rem',\r\n          left: '0.3rem',\r\n          transformOrigin: '0% 0%',\r\n          transform: `rotate(${\r\n            pacManAnimationPhase === 2\r\n              ? '0'\r\n              : pacManAnimationPhase === 1\r\n              ? '25'\r\n              : '45'\r\n          }deg)`,\r\n        }}\r\n        src={mouth}\r\n      />\r\n    </div>\r\n  );\r\n};\r\nexport default MikeSprite;\r\n","import { CSSProperties, FC } from 'react';\r\nimport { PacManDyingPhase } from '../../../model/pacManDyingPhase';\r\nimport head from './head.png';\r\nimport mouth from './mouth.png';\r\nconst MikeSpriteEnd: FC<{\r\n  dyingPacManAnimationPhase: PacManDyingPhase;\r\n  x: number;\r\n  y: number;\r\n  style?: CSSProperties;\r\n}> = ({ dyingPacManAnimationPhase, x, y }) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        height: '2rem',\r\n        width: '3rem',\r\n        position: 'absolute',\r\n        left: x,\r\n        top: y,\r\n        transform: ``,\r\n        filter: `grayscale(${dyingPacManAnimationPhase / 10})`,\r\n      }}\r\n    >\r\n      <img\r\n        style={{\r\n          width: '1.5rem',\r\n          position: 'absolute',\r\n          top: '0rem',\r\n          left: '0rem',\r\n        }}\r\n        src={head}\r\n      />\r\n      <img\r\n        style={{\r\n          width: '1rem',\r\n          position: 'absolute',\r\n          top: '1.3rem',\r\n          left: '0.3rem',\r\n        }}\r\n        src={mouth}\r\n      />\r\n    </div>\r\n  );\r\n};\r\nexport default MikeSpriteEnd;\r\n","import React, { FC, CSSProperties } from 'react';\r\nimport { Sprite } from '../../../components/Sprite';\r\nimport { Direction } from '../../../model/Types';\r\nimport { observer } from 'mobx-react-lite';\r\nimport { useGame, useStore } from '../../../components/StoreContext';\r\nimport {\r\n  SCREEN_TILE_SIZE,\r\n  SCREEN_TILE_CENTER,\r\n} from '../../../model/Coordinates';\r\nimport { Box } from '../../../components/Box';\r\nimport { PacMan } from '../../../model/PacMan';\r\nimport { getPacManHitBox } from '../../../model/detectCollisions';\r\nimport {\r\n  PacManDyingPhase,\r\n  getPacManDyingPhase,\r\n} from '../../../model/pacManDyingPhase';\r\nimport MikeSprite from './MikeSprite';\r\nimport MikeSpriteEnd from './MikeSpriteEnd';\r\n\r\nexport type PacManAnimationPhase = 0 | 1 | 2;\r\n\r\nexport const PacManAnimationPhases: PacManAnimationPhase[] = [0, 1, 2];\r\n\r\nconst PAC_MAN_WIDTH = SCREEN_TILE_SIZE * 2;\r\nconst PAC_MAN_HEIGHT = SCREEN_TILE_SIZE * 2;\r\n\r\nconst PAC_MAN_OFFSET_X = PAC_MAN_WIDTH / 2 - 2;\r\nconst PAC_MAN_OFFSET_Y = PAC_MAN_HEIGHT / 2 - 2;\r\n\r\nexport const PacManView: FC = observer(() => {\r\n  const store = useStore();\r\n  const game = useGame();\r\n  const pacMan = game.pacMan;\r\n  const { dead, alive, screenCoordinates, direction } = pacMan;\r\n  const { gameViewOptions } = store.debugState;\r\n  const pacManAnimationPhase = getPacManAnimationPhase(pacMan);\r\n  const dyingPhase = getPacManDyingPhase(pacMan);\r\n  return (\r\n    <>\r\n      {gameViewOptions.hitBox && (\r\n        <PacManHitBox\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\r\n        />\r\n      )}\r\n      {alive && (\r\n        <PacManSprite\r\n          direction={direction}\r\n          pacManAnimationPhase={pacManAnimationPhase}\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\r\n        />\r\n      )}\r\n      {dead && (\r\n        <DyingPacManSprite\r\n          dyingPacManAnimationPhase={dyingPhase}\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_X}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - PAC_MAN_OFFSET_Y}\r\n        />\r\n      )}\r\n    </>\r\n  );\r\n});\r\n\r\nconst getPacManAnimationPhase = (pacMan: PacMan): PacManAnimationPhase => {\r\n  const step = Math.round(pacMan.game.timestamp / 200) % 4;\r\n  const phase = step === 3 ? 1 : step;\r\n  return phase as PacManAnimationPhase;\r\n};\r\n\r\nexport const PacManSprite: FC<{\r\n  direction: Direction;\r\n  pacManAnimationPhase: PacManAnimationPhase;\r\n  x: number;\r\n  y: number;\r\n  style?: CSSProperties;\r\n}> = ({ direction, pacManAnimationPhase, x, y, style }) => (\r\n  <MikeSprite\r\n    x={x}\r\n    y={y}\r\n    pacManAnimationPhase={pacManAnimationPhase}\r\n    direction={direction}\r\n  />\r\n  // <Sprite\r\n  //   className=\"Sprite-pacman\"\r\n  //   name={`pacman-direction-${direction}-phase-${pacManAnimationPhase}`}\r\n  //   x={x}\r\n  //   y={y}\r\n  //   style={style}\r\n  // />\r\n);\r\n\r\nexport const DyingPacManSprite: FC<{\r\n  dyingPacManAnimationPhase: PacManDyingPhase;\r\n  x: number;\r\n  y: number;\r\n  style?: CSSProperties;\r\n}> = ({ dyingPacManAnimationPhase, x, y, style }) => (\r\n  <MikeSpriteEnd\r\n    x={x}\r\n    y={y}\r\n    dyingPacManAnimationPhase={dyingPacManAnimationPhase}\r\n    style={style}\r\n  />\r\n);\r\n\r\nexport const PacManHitBox: FC<{ x: number; y: number }> = ({ x, y }) => {\r\n  const rect = getPacManHitBox({ x, y });\r\n  return <Box rect={rect} color=\"green\" />;\r\n};\r\n","import { observer } from 'mobx-react-lite';\r\nimport React from 'react';\r\nimport { useGame } from '../../../components/StoreContext';\r\nimport classNames from 'classnames';\r\nimport styled from 'styled-components/macro';\r\nimport { PacManSprite } from './PacManView';\r\nimport { times } from 'lodash';\r\nimport { SCALE_FACTOR } from '../../../model/Coordinates';\r\n\r\nexport const ExtraLives = observer<{ className?: string }>(({ className }) => {\r\n  const game = useGame();\r\n  return (\r\n    <Layout className={classNames('ExtraLives', className)}>\r\n      <span>\r\n        {times(game.pacMan.extraLivesLeft, n => (\r\n          <PacManSprite\r\n            key={n}\r\n            direction=\"LEFT\"\r\n            pacManAnimationPhase={1}\r\n            x={n * 20 * SCALE_FACTOR}\r\n            y={0}\r\n          />\r\n        ))}\r\n      </span>\r\n    </Layout>\r\n  );\r\n});\r\n\r\nconst Layout = styled.div`\r\n  display: inline-flex;\r\n  position: relative;\r\n  width: calc(1 * 40px * var(--SCALE_FACTOR));\r\n  height: calc(16px * var(--SCALE_FACTOR));\r\n`;\r\n","import { observer } from 'mobx-react-lite';\r\nimport React from 'react';\r\nimport styled from 'styled-components/macro';\r\n\r\nexport const Message = observer<{ className?: string; text: string }>(\r\n  ({ className, text }) => {\r\n    return <MessageStyled className={className}>{text}</MessageStyled>;\r\n  }\r\n);\r\n\r\nconst MessageStyled = styled.span`\r\n  font-family: Joystix;\r\n  font-size: 24px;\r\n  color: yellow;\r\n  position: absolute;\r\n  left: 170px;\r\n  top: 332px;\r\n  width: 220px;\r\n  text-align: center;\r\n`;\r\n","import { observer } from 'mobx-react-lite';\r\nimport React, { FC } from 'react';\r\nimport './GameOver.css';\r\nimport { useGame } from '../../../components/StoreContext';\r\nimport { Message } from './Message';\r\nimport { TotalPacManDyingAnimationLength } from '../../../model/pacManDyingPhase';\r\n\r\nexport const TOTAL_TIME_TO_GAME_OVER_MESSAGE = TotalPacManDyingAnimationLength;\r\n\r\nexport const GameOver: FC<{ className?: string }> = observer(\r\n  ({ className }) => {\r\n    const game = useGame();\r\n    const { pacMan } = game;\r\n    const gameOverMessageVisible =\r\n      game.gameOver && pacMan.timeSinceDeath >= TOTAL_TIME_TO_GAME_OVER_MESSAGE;\r\n\r\n    return gameOverMessageVisible ? <Message text=\"Game Over\" /> : null;\r\n  }\r\n);\r\n","import React from 'react';\r\nimport { ScreenCoordinates, SCREEN_TILE_SIZE } from '../../model/Coordinates';\r\nimport styled from 'styled-components/macro';\r\nimport { Direction } from '../../model/Types';\r\n\r\nconst x1 = 30;\r\nconst y1 = 30;\r\nconst x2 = 70;\r\nconst y2 = 70;\r\nconst x3 = 50;\r\nconst POINTS = `${x1},${y1} ${x2},${y1} ${x3},${y2} ${x1},${y1}`;\r\n\r\nconst DirectionToAngle = {\r\n  DOWN: 0,\r\n  LEFT: 90,\r\n  UP: 180,\r\n  RIGHT: 270,\r\n};\r\n\r\nexport const WayPoint: React.FC<{\r\n  screenCoordinates: ScreenCoordinates;\r\n  color: string;\r\n  direction: Direction;\r\n}> = ({ screenCoordinates, color, direction }) => {\r\n  const angle = DirectionToAngle[direction];\r\n  return (\r\n    <SvgStyled\r\n      viewBox=\"0 0 100 100\"\r\n      height=\"6\"\r\n      width=\"6\"\r\n      style={{\r\n        left: `${screenCoordinates.x + 1}px`,\r\n        top: `${screenCoordinates.y}px`,\r\n      }}\r\n    >\r\n      <g transform={`rotate(${angle} 50 50)`}>\r\n        <polygon points={POINTS} fill={color} stroke={color} strokeWidth={1} />\r\n      </g>\r\n    </SvgStyled>\r\n  );\r\n};\r\n\r\nconst SvgStyled = styled.svg`\r\n  position: absolute;\r\n  display: block;\r\n  width: ${SCREEN_TILE_SIZE}px;\r\n  height: ${SCREEN_TILE_SIZE}px;\r\n  pointer-events: none;\r\n`;\r\n","import { TileCoordinates, TileCoordinate } from './Coordinates';\r\nimport { isEqual } from 'lodash';\r\nimport { assert } from '../util/assert';\r\nimport { Direction } from './Types';\r\nimport { MAZE_WIDTH_IN_TILES } from './MazeData';\r\n\r\nconst TUNNEL_X_LEFT: TileCoordinate = 0;\r\nconst TUNNEL_X_RIGHT: TileCoordinate = MAZE_WIDTH_IN_TILES - 1;\r\n\r\nexport const getDirectionFromTileToTile = (\r\n  tileFrom: TileCoordinates,\r\n  tileTo: TileCoordinates\r\n): Direction => {\r\n  assert(tileFrom, 'tileFrom');\r\n  assert(tileTo, 'tileTo');\r\n\r\n  if (isEqual(tileFrom, tileTo)) {\r\n    throw new Error('Same tile');\r\n  }\r\n\r\n  // Go through the tunnel?\r\n  if (tileFrom.x === TUNNEL_X_RIGHT && tileTo.x === TUNNEL_X_LEFT) {\r\n    return 'RIGHT';\r\n  }\r\n  // Go through the tunnel?\r\n  if (tileFrom.x === TUNNEL_X_LEFT && tileTo.x === TUNNEL_X_RIGHT) {\r\n    return 'LEFT';\r\n  }\r\n  if (tileFrom.x < tileTo.x) {\r\n    return 'RIGHT';\r\n  }\r\n  if (tileFrom.x > tileTo.x) {\r\n    return 'LEFT';\r\n  }\r\n  if (tileFrom.y < tileTo.y) {\r\n    return 'DOWN';\r\n  }\r\n  if (tileFrom.y > tileTo.y) {\r\n    return 'UP';\r\n  }\r\n  throw new Error('Same tiles');\r\n};\r\n","/* eslint-disable react/no-unescaped-entities */\r\nimport { observer } from 'mobx-react-lite';\r\nimport React from 'react';\r\nimport { screenFromTile, TileCoordinates } from '../../model/Coordinates';\r\nimport { WayPoint } from './WayPoint';\r\nimport { getDirectionFromTileToTile } from '../../model/getDirectionFromTileToTile';\r\nimport { Direction } from '../../model/Types';\r\nimport { assert } from '../../util/assert';\r\n\r\nexport const WayPoints = observer<{\r\n  wayPoints: TileCoordinates[];\r\n  color: string;\r\n}>(({ wayPoints, color }) => (\r\n  <>\r\n    {wayPoints.map((wayPoint, index) => {\r\n      const screenCoordinates = screenFromTile(wayPoint);\r\n      const direction = getDirection(wayPoints, index);\r\n      return (\r\n        <WayPoint\r\n          key={index}\r\n          screenCoordinates={screenCoordinates}\r\n          color={color}\r\n          direction={direction}\r\n        />\r\n      );\r\n    })}\r\n  </>\r\n));\r\n\r\nconst getDirection = (\r\n  wayPoints: TileCoordinates[],\r\n  index: number\r\n): Direction => {\r\n  if (wayPoints.length <= 1) {\r\n    return 'DOWN';\r\n  }\r\n  const indexToUse = index + 1 < wayPoints.length ? index : index - 1;\r\n  const fromTile = wayPoints[indexToUse];\r\n  const toTile = wayPoints[indexToUse + 1];\r\n  assert(toTile, `${indexToUse} ${wayPoints.length}`);\r\n  const direction = getDirectionFromTileToTile(fromTile, toTile);\r\n  return direction;\r\n};\r\n","import React, { FC, CSSProperties } from 'react';\r\nimport classNames from 'classnames';\r\nimport { SCALE_FACTOR } from '../model/Coordinates';\r\nimport './Sprite.css';\r\n\r\nconst scale = `scale(${SCALE_FACTOR})`;\r\n\r\nexport const Sprite: FC<{\r\n  name: string;\r\n  x: number;\r\n  y: number;\r\n  className?: string | null;\r\n  style?: CSSProperties;\r\n}> = ({ name: spriteName, x, y, className, style = {} }) => {\r\n  return (\r\n    <div\r\n      className={classNames('Sprite', 'Sprite-' + spriteName, className)}\r\n      style={{\r\n        ...style,\r\n        position: 'absolute',\r\n        left: `${x}px`,\r\n        top: `${y}px`,\r\n        transform: scale,\r\n        transformOrigin: 'top left',\r\n      }}\r\n    />\r\n  );\r\n};\r\n","import React, { FC } from 'react';\r\nimport {\r\n  TileCoordinates,\r\n  SCREEN_TILE_SIZE,\r\n  screenFromTileCoordinate,\r\n  SCREEN_TILE_CENTER,\r\n} from '../../../model/Coordinates';\r\n\r\nconst SIZE = SCREEN_TILE_SIZE * 2;\r\nconst OFFSET = SCREEN_TILE_CENTER - SIZE / 2;\r\n\r\nexport const Target: FC<{ tile: TileCoordinates; color: string }> = ({\r\n  tile,\r\n  color,\r\n}) => (\r\n  <div\r\n    style={{\r\n      position: 'absolute',\r\n      left: screenFromTileCoordinate(tile.x) + OFFSET,\r\n      top: screenFromTileCoordinate(tile.y) + OFFSET,\r\n      width: SIZE,\r\n      height: SIZE,\r\n    }}\r\n  >\r\n    <svg version=\"1.1\" viewBox=\"0 0 22 22\">\r\n      <path\r\n        style={{ fill: color }}\r\n        transform={`rotate(45 11 11) translate(-550.29-608.65)`}\r\n        d=\"m559.29 611.65v1 5h-5-1v4h1 5v5 1h4v-1-5h6v-1-2-1h-1-5v-5-1z\"\r\n      />\r\n    </svg>\r\n  </div>\r\n);\r\n","import { observer } from 'mobx-react-lite';\r\nimport React, { FC } from 'react';\r\nimport {\r\n  SCREEN_TILE_SIZE,\r\n  SCREEN_TILE_CENTER,\r\n} from '../../../model/Coordinates';\r\nimport { getGhostHitBox } from '../../../model/detectCollisions';\r\nimport {\r\n  Ghost,\r\n  GhostAnimationPhase,\r\n  FrightenedGhostTime,\r\n} from '../../../model/Ghost';\r\nimport { Direction } from '../../../model/Types';\r\nimport { WayPoints } from '../../WayFindingPage/WayPoints';\r\nimport { Box } from '../../../components/Box';\r\nimport { Sprite } from '../../../components/Sprite';\r\nimport { useGame, useStore } from '../../../components/StoreContext';\r\nimport { Target } from './Target';\r\nimport { GhostViewOptions } from '../../../model/GhostViewOptions';\r\nimport { GameViewOptions } from '../../../model/GameViewOptions';\r\n\r\nconst GHOST_WIDTH = SCREEN_TILE_SIZE * 2;\r\nconst GHOST_HEIGHT = SCREEN_TILE_SIZE * 2;\r\n\r\nconst GHOST_OFFSET_X = GHOST_WIDTH / 2 - 0;\r\nconst GHOST_OFFSET_Y = GHOST_HEIGHT / 2;\r\n\r\nexport const GhostsGameView = observer(() => {\r\n  const store = useStore();\r\n  const { ghostViewOptions, gameViewOptions } = store.debugState;\r\n\r\n  return (\r\n    <GhostsView\r\n      ghostViewOptions={ghostViewOptions}\r\n      gameViewOptions={gameViewOptions}\r\n    />\r\n  );\r\n});\r\n\r\nexport const GhostsView: FC<{\r\n  ghostViewOptions?: GhostViewOptions;\r\n  gameViewOptions?: GameViewOptions;\r\n}> = observer(\r\n  ({\r\n    ghostViewOptions = DefaultGhostViewOptions,\r\n    gameViewOptions = DefaultGameViewOptions,\r\n  }) => {\r\n    const store = useGame();\r\n\r\n    return (\r\n      <>\r\n        {store.ghosts.map(ghost => (\r\n          <GhostCompositeView\r\n            key={ghost.ghostNumber}\r\n            ghost={ghost}\r\n            ghostViewOptions={ghostViewOptions}\r\n            gameViewOptions={gameViewOptions}\r\n          />\r\n        ))}\r\n      </>\r\n    );\r\n  }\r\n);\r\n\r\nconst DefaultGhostViewOptions: GhostViewOptions = {\r\n  target: false,\r\n  wayPoints: false,\r\n};\r\n\r\nconst DefaultGameViewOptions: GameViewOptions = {\r\n  hitBox: false,\r\n};\r\n\r\nexport const GhostCompositeView: FC<{\r\n  ghost: Ghost;\r\n  ghostViewOptions: GhostViewOptions;\r\n  gameViewOptions: GameViewOptions;\r\n}> = observer(({ ghost, ghostViewOptions, gameViewOptions }) => {\r\n  const { screenCoordinates } = ghost;\r\n  return (\r\n    <>\r\n      {gameViewOptions.hitBox && (\r\n        <GhostHitBox\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER}\r\n          color=\"green\"\r\n        />\r\n      )}\r\n      <GhostView ghost={ghost} />\r\n      {ghostViewOptions.wayPoints && (\r\n        <WayPoints wayPoints={ghost.wayPoints ?? []} color={ghost.colorCode} />\r\n      )}\r\n      {ghostViewOptions.target && (\r\n        <Target tile={ghost.targetTile} color={ghost.colorCode} />\r\n      )}\r\n    </>\r\n  );\r\n});\r\n\r\nexport const GhostView: FC<{\r\n  ghost: Ghost;\r\n}> = observer(({ ghost }) => {\r\n  const { screenCoordinates, animationPhase, direction, ghostNumber } = ghost;\r\n  // TODO\r\n  switch (ghost.state) {\r\n    case 'frightened':\r\n      return (\r\n        <FrightenedGhostSprite\r\n          frightenedGhostTime={ghost.frightenedGhostTime}\r\n          ghostAnimationPhase={animationPhase}\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\r\n        />\r\n      );\r\n    case 'dead':\r\n      return (\r\n        <DeadGhostSprite\r\n          direction={direction}\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\r\n        />\r\n      );\r\n    default:\r\n      return (\r\n        <GhostSprite\r\n          direction={direction}\r\n          ghostAnimationPhase={animationPhase}\r\n          x={screenCoordinates.x + SCREEN_TILE_CENTER - GHOST_OFFSET_X}\r\n          y={screenCoordinates.y + SCREEN_TILE_CENTER - GHOST_OFFSET_Y}\r\n          ghostNumber={ghostNumber}\r\n        />\r\n      );\r\n  }\r\n});\r\n\r\ntype GhostSpriteProps = {\r\n  direction: Direction;\r\n  ghostAnimationPhase: GhostAnimationPhase;\r\n  x: number;\r\n  y: number;\r\n  ghostNumber: number;\r\n  style?: { [key: string]: any };\r\n};\r\n\r\nexport const GhostSprite: FC<GhostSpriteProps> = ({\r\n  direction,\r\n  ghostAnimationPhase: phase,\r\n  x,\r\n  y,\r\n  ghostNumber,\r\n  style,\r\n}) => (\r\n  <Sprite\r\n    className=\"Sprite-ghost\"\r\n    name={`ghost-${ghostNumber}-direction-${direction}-phase-${phase}`}\r\n    x={x}\r\n    y={y}\r\n    style={style}\r\n  />\r\n);\r\n\r\ntype DeadGhostSpriteProps = {\r\n  direction: Direction;\r\n  x: number;\r\n  y: number;\r\n  style?: { [key: string]: any };\r\n};\r\n\r\nexport const DeadGhostSprite: FC<DeadGhostSpriteProps> = ({\r\n  direction,\r\n  x,\r\n  y,\r\n  style,\r\n}) => (\r\n  <Sprite\r\n    className=\"Sprite-ghost\"\r\n    name={`dead-ghost-direction-${direction}`}\r\n    x={x}\r\n    y={y}\r\n    style={style}\r\n  />\r\n);\r\n\r\ntype FrightenedGhostSpriteProps = {\r\n  x: number;\r\n  y: number;\r\n  ghostAnimationPhase: GhostAnimationPhase;\r\n  frightenedGhostTime: FrightenedGhostTime;\r\n  style?: { [key: string]: any };\r\n};\r\n\r\nexport const FrightenedGhostSprite: FC<FrightenedGhostSpriteProps> = ({\r\n  x,\r\n  y,\r\n  ghostAnimationPhase,\r\n  frightenedGhostTime,\r\n  style,\r\n}) => (\r\n  <Sprite\r\n    className=\"Sprite-ghost\"\r\n    name={`frightened-ghost-time-${frightenedGhostTime}-phase-${ghostAnimationPhase}`}\r\n    x={x}\r\n    y={y}\r\n    style={style}\r\n  />\r\n);\r\n\r\nexport const GhostHitBox: FC<{ x: number; y: number; color: string }> = ({\r\n  x,\r\n  y,\r\n  color,\r\n}) => {\r\n  const rect = getGhostHitBox({ x, y });\r\n  return <Box rect={rect} color={color} />;\r\n};\r\n","import React, { FC } from 'react';\r\nimport { Sprite } from '../../../components/Sprite';\r\n\r\nexport const MazeView: FC = () => (\r\n  <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\r\n);\r\n","import { observer } from 'mobx-react-lite';\r\nimport React, { FC, memo } from 'react';\r\nimport { Box } from '../../../components/Box';\r\nimport { Sprite } from '../../../components/Sprite';\r\nimport {\r\n  addCoordinatesAndVector,\r\n  ScreenCoordinates,\r\n  screenFromTile,\r\n  SCREEN_TILE_CENTER_VECTOR,\r\n  TileCoordinates,\r\n} from '../../../model/Coordinates';\r\nimport { getPillHitBox } from '../../../model/detectCollisions';\r\nimport {\r\n  BASIC_PILL_ID,\r\n  ENERGIZER_ID,\r\n  MAZE_HEIGHT_IN_TILES,\r\n  MAZE_WIDTH_IN_TILES,\r\n  EMPTY_TILE_ID,\r\n} from '../../../model/MazeData';\r\nimport { useGame } from '../../../components/StoreContext';\r\nimport wine from './wine.png';\r\nconst BasicPillView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\r\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"basic-pill\" />\r\n);\r\n\r\nconst EnergizerView: FC<{ position: ScreenCoordinates }> = ({ position }) => (\r\n  <Sprite x={position.x - 10} y={position.y - 10} name=\"energizer\" />\r\n);\r\n\r\nexport const BasicPillHitBox: FC = () => {\r\n  const rect = getPillHitBox({ x: 1, y: 3 }, BASIC_PILL_ID);\r\n  return <Box rect={rect} color=\"blue\" />;\r\n};\r\n\r\nconst PillView = observer<{ tile: TileCoordinates }>(\r\n  ({ tile }: { tile: TileCoordinates }) => {\r\n    const game = useGame();\r\n    const { x, y } = tile;\r\n    const tileId = game.maze.pills[y][x];\r\n    if (tileId === BASIC_PILL_ID) {\r\n      return (\r\n        <BasicPillView\r\n          position={addCoordinatesAndVector(\r\n            screenFromTile(tile),\r\n            SCREEN_TILE_CENTER_VECTOR\r\n          )}\r\n        />\r\n      );\r\n    }\r\n    if (tileId === ENERGIZER_ID) {\r\n      const { x, y } = addCoordinatesAndVector(\r\n        screenFromTile(tile),\r\n        SCREEN_TILE_CENTER_VECTOR\r\n      );\r\n      console.log('tile');\r\n      return (\r\n        <div\r\n          style={{\r\n            position: 'absolute',\r\n            width: '20px',\r\n            height: '20px',\r\n            left: x - 10,\r\n            top: y - 10,\r\n            background: 'white',\r\n          }}\r\n        >\r\n          <img\r\n            src={wine}\r\n            style={{\r\n              position: 'absolute',\r\n              top: -55,\r\n              left: -45,\r\n              width: '90px',\r\n            }}\r\n          />\r\n        </div>\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n);\r\n\r\n// Performance tricks used here:\r\n// Make each PillView an observer, so that we don't have to rerender PillsView.\r\n// Make PillsView a React.memo to prevent any rerenders.\r\n// Also: Create PillView only for those coordinates where there is a pill on first render.\r\nexport const PillsView: FC = memo(() => {\r\n  const game = useGame();\r\n\r\n  return (\r\n    <>\r\n      {Array.from({ length: MAZE_HEIGHT_IN_TILES }).map((_, y) =>\r\n        Array.from({ length: MAZE_WIDTH_IN_TILES }).map((_, x) => {\r\n          const pillFound = game.maze.pills[y][x] !== EMPTY_TILE_ID;\r\n          return pillFound && <PillView key={`${x}/${y}`} tile={{ x, y }} />;\r\n        })\r\n      )}\r\n    </>\r\n  );\r\n});\r\n\r\nPillsView.displayName = 'displayName';\r\n","export default \"data:image/png;base64,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\"","import { observer } from 'mobx-react-lite';\r\nimport React from 'react';\r\nimport { useGame } from '../../../components/StoreContext';\r\nimport './Score.css';\r\nimport classNames from 'classnames';\r\n\r\nexport const Score = observer<{ className?: string }>(({ className }) => {\r\n  const store = useGame();\r\n  return (\r\n    <div className={classNames('Score', className)}>\r\n      <span>Score</span>\r\n      <span>{store.score}</span>\r\n    </div>\r\n  );\r\n});\r\n","import styled from 'styled-components/macro';\r\n\r\nconst DEFAULT_SIZE = '8px';\r\n\r\nconst SIZE_MAPPING: { [key: string]: string } = {\r\n  small: '8px',\r\n  medium: '16px',\r\n  large: '24px',\r\n};\r\n\r\ntype Size = 'small' | 'middle' | 'large' | string;\r\nconst mappedSize = (size: Size): string => SIZE_MAPPING[size] ?? size;\r\n\r\nexport const HSpace = styled.div<{ size?: Size }>`\r\n  width: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\r\n`;\r\n\r\nexport const VSpace = styled.div<{ size?: Size }>`\r\n  height: ${({ size = DEFAULT_SIZE }) => mappedSize(size)};\r\n`;\r\n","import { assert } from '../util/assert';\r\n\r\nexport type PixelsPerFrame = number;\r\n\r\nexport type Direction = 'UP' | 'DOWN' | 'RIGHT' | 'LEFT';\r\n\r\nexport const Directions: Direction[] = ['UP', 'DOWN', 'LEFT', 'RIGHT'];\r\n\r\nexport type MilliSeconds = number;\r\n\r\nexport const assertValidDirection = (direction: Direction) => {\r\n  assert(Directions.includes(direction), `Bad direction ${direction}`);\r\n};\r\n","export interface Vector {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport const rotateVectorBy180Degrees = (vector: Vector): Vector =>\r\n  multiplyVector(-1, vector);\r\n\r\nexport const multiplyVector = (factor: number, vector: Vector): Vector => ({\r\n  x: factor * vector.x,\r\n  y: factor * vector.y,\r\n});\r\n\r\nexport const divideVector = (vector: Vector, divisor: number): Vector =>\r\n  multiplyVector(1 / divisor, vector);\r\n","import { Direction, assertValidDirection } from './Types';\r\nimport {\r\n  assertValidTileCoordinates,\r\n  ScreenCoordinates,\r\n  TileCoordinates,\r\n  SCREEN_TILE_SIZE,\r\n  rectangleContainsTile,\r\n  TileRectangle,\r\n  wrapTileToBounds,\r\n  MAZE_DIMENSIONS_IN_TILES,\r\n  addCoordinatesAndVector,\r\n} from './Coordinates';\r\nimport { waysMatrix, WAY_FREE_ID, BOX_DOOR_ID } from './MazeData';\r\nimport { Vector, multiplyVector } from './Vector';\r\n\r\nconst BOX_TILE_COORDINATES: TileRectangle = {\r\n  tile1: { x: 10, y: 12 },\r\n  tile2: { x: 17, y: 16 },\r\n};\r\n\r\nconst BOX_SPACE_TILE_COORDINATES: TileRectangle = {\r\n  tile1: { x: 12, y: 14 },\r\n  tile2: { x: 15, y: 14 },\r\n};\r\n\r\nexport const isWayFreeAt = (tile: TileCoordinates): boolean => {\r\n  assertValidTileCoordinates(tile);\r\n  return waysMatrix[tile.y][tile.x] === WAY_FREE_ID;\r\n};\r\n\r\nexport const isBoxDoorAt = (tile: TileCoordinates): boolean => {\r\n  assertValidTileCoordinates(tile);\r\n  return waysMatrix[tile.y][tile.x] === BOX_DOOR_ID;\r\n};\r\n\r\nexport const isTileInBox = (tile: TileCoordinates): boolean =>\r\n  rectangleContainsTile(BOX_TILE_COORDINATES, tile);\r\n\r\nexport const isTileInBoxSpace = (tile: TileCoordinates): boolean =>\r\n  rectangleContainsTile(BOX_SPACE_TILE_COORDINATES, tile);\r\n\r\nexport const isTileCenter = (screen: ScreenCoordinates): boolean => {\r\n  return screen.x % SCREEN_TILE_SIZE === 0 && screen.y % SCREEN_TILE_SIZE === 0;\r\n};\r\n\r\nexport const DIRECTION_TO_VECTOR: Record<Direction, Vector> = {\r\n  RIGHT: { x: 1, y: 0 },\r\n  LEFT: { x: -1, y: 0 },\r\n  UP: { x: 0, y: -1 },\r\n  DOWN: { x: 0, y: 1 },\r\n};\r\n\r\nexport const directionToVector = (direction: Direction, distance = 1): Vector =>\r\n  multiplyVector(distance, DIRECTION_TO_VECTOR[direction]);\r\n\r\nexport const moveFromTile = (\r\n  tile: TileCoordinates,\r\n  direction: Direction,\r\n  steps = 1\r\n) => {\r\n  const step = DIRECTION_TO_VECTOR[direction];\r\n  const newTile = { x: tile.x + step.x * steps, y: tile.y + step.y * steps };\r\n  return newTile;\r\n};\r\n\r\nexport const DIRECTION_TO_OPPOSITE_DIRECTION: Record<Direction, Direction> = {\r\n  RIGHT: 'LEFT',\r\n  LEFT: 'RIGHT',\r\n  UP: 'DOWN',\r\n  DOWN: 'UP',\r\n};\r\n\r\nexport const isOppositeDirection = (\r\n  direction1: Direction,\r\n  direction2: Direction\r\n) => {\r\n  return DIRECTION_TO_OPPOSITE_DIRECTION[direction1] === direction2;\r\n};\r\n\r\nexport const isWayFreeInDirection = (\r\n  tile: TileCoordinates,\r\n  direction: Direction,\r\n  stepSize = 1\r\n): boolean => {\r\n  const nextTile = getNextTile(tile, direction, stepSize);\r\n  return isWayFreeAt(nextTile);\r\n};\r\n\r\nexport const getNextTile = (\r\n  tile: TileCoordinates,\r\n  direction: Direction,\r\n  stepSize = 1\r\n): TileCoordinates => {\r\n  assertValidDirection(direction);\r\n  const vector: Vector = DIRECTION_TO_TILE_VECTOR[direction];\r\n  const scaledVector = multiplyVector(stepSize, vector);\r\n  const movedTile = addCoordinatesAndVector(tile, scaledVector);\r\n  const nextTile = wrapTileToBounds(movedTile, MAZE_DIMENSIONS_IN_TILES);\r\n  return nextTile;\r\n};\r\n\r\nconst DIRECTION_TO_TILE_VECTOR = {\r\n  RIGHT: { x: 1, y: 0 },\r\n  LEFT: { x: -1, y: 0 },\r\n  UP: { x: 0, y: -1 },\r\n  DOWN: { x: 0, y: 1 },\r\n};\r\n","import { TileCoordinates } from './Coordinates';\r\n\r\nexport const getTileDistance = (\r\n  neighbourTile: TileCoordinates,\r\n  targetTile: TileCoordinates\r\n) => {\r\n  const dx = Math.abs(neighbourTile.x - targetTile.x);\r\n  const dy = Math.abs(neighbourTile.y - targetTile.y);\r\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n};\r\n","import {\r\n  TileCoordinates,\r\n  getPointDifferenceAsVector,\r\n  addCoordinatesAndVector,\r\n} from './Coordinates';\r\nimport { Ghost } from './Ghost';\r\nimport { moveFromTile, isWayFreeInDirection, getNextTile } from './Ways';\r\nimport { getTileDistance } from './getTileDistance';\r\nimport { Directions, Direction } from './Types';\r\nimport { rotateVectorBy180Degrees } from './Vector';\r\nimport { assert } from '../util/assert';\r\n\r\nexport const TILE_FOR_LEAVING_THE_BOX: TileCoordinates = {\r\n  x: 13,\r\n  y: 11,\r\n};\r\n\r\nexport const TILE_FOR_RETURNING_TO_BOX: TileCoordinates = {\r\n  x: 14,\r\n  y: 14,\r\n};\r\n\r\nexport const SCATTER_TILE_FOR_GHOST_0: TileCoordinates = { x: 26, y: 1 };\r\n\r\nexport const chooseNewTargetTile = (ghost: Ghost): TileCoordinates => {\r\n  switch (ghost.state) {\r\n    case 'scatter':\r\n      return chooseInScatterMode(ghost);\r\n    case 'chase':\r\n      return choseInChaseMode(ghost);\r\n    case 'frightened':\r\n      return chooseInFrightenedMode(ghost);\r\n    case 'dead':\r\n      return chooseInDeadMode(ghost);\r\n    default:\r\n      throw new Error(`Bad state ${ghost.state}`);\r\n  }\r\n};\r\n\r\nconst chooseInScatterMode = (ghost: Ghost): TileCoordinates => {\r\n  if (ghost.isInsideBoxWalls) {\r\n    return TILE_FOR_LEAVING_THE_BOX;\r\n  }\r\n  switch (ghost.ghostNumber) {\r\n    case 0:\r\n      return SCATTER_TILE_FOR_GHOST_0;\r\n    case 1:\r\n      return { x: 1, y: 1 };\r\n    case 2:\r\n      return { x: 26, y: 29 };\r\n    case 3:\r\n      return { x: 1, y: 29 };\r\n    default:\r\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\r\n  }\r\n};\r\n\r\nconst chooseForGhost0InChaseState = (ghost: Ghost): TileCoordinates => {\r\n  const pacMan = ghost.game.pacMan;\r\n  return pacMan.tileCoordinates;\r\n};\r\n\r\nconst chooseForGhost1InChaseState = (ghost: Ghost): TileCoordinates => {\r\n  const pacMan = ghost.game.pacMan;\r\n  const fourTilesAhead = moveFromTile(\r\n    pacMan.tileCoordinates,\r\n    pacMan.direction,\r\n    4\r\n  );\r\n  return pacMan.direction === 'UP'\r\n    ? moveFromTile(fourTilesAhead, 'LEFT', 4)\r\n    : fourTilesAhead;\r\n};\r\n\r\nconst chooseForGhost2InChaseState = (ghost: Ghost): TileCoordinates => {\r\n  const intermediateTile = chooseGhost2IntermediateTile(ghost);\r\n  const blinky = ghost.game.ghosts[0];\r\n  const vectorToBlinky = getPointDifferenceAsVector(\r\n    intermediateTile,\r\n    blinky.tileCoordinates\r\n  );\r\n  const rotatedVector = rotateVectorBy180Degrees(vectorToBlinky);\r\n  const newTile = addCoordinatesAndVector(intermediateTile, rotatedVector);\r\n\r\n  return newTile;\r\n};\r\n\r\nexport const chooseGhost2IntermediateTile = (ghost: Ghost): TileCoordinates => {\r\n  const pacMan = ghost.game.pacMan;\r\n  const twoTilesAhead = moveFromTile(\r\n    pacMan.tileCoordinates,\r\n    pacMan.direction,\r\n    2\r\n  );\r\n  return pacMan.direction === 'UP'\r\n    ? moveFromTile(twoTilesAhead, 'LEFT', 2)\r\n    : twoTilesAhead;\r\n};\r\n\r\nconst chooseForGhost3InChaseState = (ghost: Ghost): TileCoordinates => {\r\n  const pacMan = ghost.game.pacMan;\r\n  const distance = getTileDistance(\r\n    ghost.tileCoordinates,\r\n    pacMan.tileCoordinates\r\n  );\r\n\r\n  return distance >= 8 ? pacMan.tileCoordinates : chooseInScatterMode(ghost);\r\n};\r\n\r\nconst choseInChaseMode = (ghost: Ghost): TileCoordinates => {\r\n  if (ghost.isInsideBoxWalls) {\r\n    return TILE_FOR_LEAVING_THE_BOX;\r\n  }\r\n  switch (ghost.ghostNumber) {\r\n    case 0:\r\n      return chooseForGhost0InChaseState(ghost);\r\n    case 1:\r\n      return chooseForGhost1InChaseState(ghost);\r\n    case 2:\r\n      return chooseForGhost2InChaseState(ghost);\r\n    case 3:\r\n      return chooseForGhost3InChaseState(ghost);\r\n    default:\r\n      throw new Error(`Bad ghostNumber ${ghost.ghostNumber}`);\r\n  }\r\n};\r\n\r\nconst getRandomInt = (max: number) =>\r\n  Math.floor(Math.random() * Math.floor(max));\r\n\r\nconst chooseInFrightenedMode = (ghost: Ghost): TileCoordinates => {\r\n  // Choose a random neighbour tile that is not backward and not into a wall.\r\n\r\n  return chooseSomeRandomMovement(ghost);\r\n};\r\n\r\n/**\r\n * Choose a random neighbour tile that is not backward and not into a wall.\r\n */\r\nconst chooseSomeRandomMovement = (ghost: Ghost): TileCoordinates => {\r\n  const candidateDirections: Direction[] = Directions.filter(\r\n    direction =>\r\n      direction !== ghost.direction &&\r\n      isWayFreeInDirection(ghost.tileCoordinates, direction)\r\n  );\r\n  assert(candidateDirections.length > 0);\r\n  const newDirection =\r\n    candidateDirections[getRandomInt(candidateDirections.length)];\r\n  assert(newDirection);\r\n  const randomNeighourTile = getNextTile(ghost.tileCoordinates, newDirection);\r\n\r\n  return randomNeighourTile;\r\n};\r\n\r\nconst chooseInDeadMode = (ghost: Ghost): TileCoordinates => {\r\n  // if (ghost.deadWaitingTimeInBoxLeft < 0) {\r\n  //   return chooseSomeRandomMovement(ghost);\r\n  // }\r\n  return TILE_FOR_RETURNING_TO_BOX;\r\n};\r\n","import { minBy } from 'lodash';\r\nimport { isValidTileCoordinates, TileCoordinates } from './Coordinates';\r\nimport { Direction, Directions } from './Types';\r\nimport {\r\n  getNextTile,\r\n  isOppositeDirection,\r\n  isWayFreeAt,\r\n  isBoxDoorAt,\r\n} from './Ways';\r\nimport { getTileDistance } from './getTileDistance';\r\nimport { toJS } from 'mobx';\r\nimport { assert } from '../util/assert';\r\n\r\ninterface CandidateTile {\r\n  tile: TileCoordinates;\r\n  distanceToTarget: number;\r\n}\r\n\r\nexport const chooseNextTile = ({\r\n  currentTile,\r\n  currentDirection,\r\n  targetTile,\r\n  boxDoorIsOpen,\r\n}: {\r\n  currentTile: TileCoordinates;\r\n  currentDirection: Direction;\r\n  targetTile: TileCoordinates;\r\n  boxDoorIsOpen: boolean;\r\n}): TileCoordinates => {\r\n  assert(isValidTileCoordinates(currentTile), `${toJS(currentTile)}`);\r\n  const bestNextTile = chooseBestNextTile({\r\n    currentTile,\r\n    currentDirection,\r\n    targetTile,\r\n    boxDoorIsOpen,\r\n  });\r\n\r\n  if (bestNextTile) {\r\n    assert(isValidTileCoordinates(bestNextTile));\r\n    return bestNextTile;\r\n  }\r\n\r\n  const anyNextTile = chooseAnyNextTile({\r\n    currentTile,\r\n    currentDirection,\r\n    boxDoorIsOpen,\r\n  });\r\n  if (anyNextTile) {\r\n    assert(isValidTileCoordinates(anyNextTile));\r\n    return anyNextTile;\r\n  }\r\n\r\n  console.error('currentTile', currentTile);\r\n  console.error('currentDirection', currentDirection);\r\n  console.error('boxDoorIsOpen', boxDoorIsOpen);\r\n  console.error('targetTile', toJS(targetTile));\r\n\r\n  throw new Error(`Found no candidate at ${JSON.stringify(currentTile)}`);\r\n};\r\n\r\nconst chooseBestNextTile = ({\r\n  currentTile,\r\n  currentDirection,\r\n  targetTile,\r\n  boxDoorIsOpen,\r\n}: {\r\n  currentTile: TileCoordinates;\r\n  currentDirection: Direction;\r\n  targetTile: TileCoordinates;\r\n  boxDoorIsOpen: boolean;\r\n}): TileCoordinates | null => {\r\n  const candidates = [] as CandidateTile[];\r\n  for (const direction of Directions) {\r\n    // Prevent the ghost from going backwards\r\n    if (isOppositeDirection(direction, currentDirection)) {\r\n      continue;\r\n    }\r\n    const neighbourTile = getNextTile(currentTile, direction);\r\n\r\n    if (!possibleNextTile(neighbourTile, boxDoorIsOpen)) {\r\n      continue;\r\n    }\r\n\r\n    const distanceToTarget = getTileDistance(neighbourTile, targetTile);\r\n    candidates.push({ tile: neighbourTile, distanceToTarget });\r\n  }\r\n\r\n  const bestCandidate = minBy(candidates, 'distanceToTarget');\r\n  if (bestCandidate) {\r\n    return bestCandidate.tile;\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n\r\nconst chooseAnyNextTile = ({\r\n  currentTile,\r\n  currentDirection,\r\n  boxDoorIsOpen,\r\n}: {\r\n  currentTile: TileCoordinates;\r\n  currentDirection: Direction;\r\n  boxDoorIsOpen: boolean;\r\n}): TileCoordinates | null => {\r\n  // Prioritize the current direction\r\n  const neighbourTileInCurrentDirection = getNextTile(\r\n    currentTile,\r\n    currentDirection\r\n  );\r\n\r\n  if (possibleNextTile(neighbourTileInCurrentDirection, boxDoorIsOpen)) {\r\n    return neighbourTileInCurrentDirection;\r\n  }\r\n\r\n  // Choose any possible next tile\r\n  for (const direction of Directions) {\r\n    const neighbourTile = getNextTile(currentTile, direction);\r\n    if (possibleNextTile(neighbourTile, boxDoorIsOpen)) {\r\n      return neighbourTile;\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nconst possibleNextTile = (\r\n  tileCoordinates: TileCoordinates,\r\n  boxDoorIsOpen: boolean\r\n): boolean => {\r\n  return (\r\n    isValidTileCoordinates(tileCoordinates) &&\r\n    isWayFreeForGhostAt(tileCoordinates, boxDoorIsOpen)\r\n  );\r\n};\r\n\r\nconst isWayFreeForGhostAt = (\r\n  tileCoordinates: TileCoordinates,\r\n  boxDoorIsOpen: boolean\r\n): boolean =>\r\n  isWayFreeAt(tileCoordinates) ||\r\n  (boxDoorIsOpen && isBoxDoorAt(tileCoordinates));\r\n","import { action } from 'mobx';\r\nimport { Ghost } from './Ghost';\r\nimport { MilliSeconds } from './Types';\r\nimport { StateValue } from 'xstate';\r\n\r\nexport const CHASE_PHASE_LENGTH = 20 * 1000;\r\nexport const SCATTER_PHASE_LENGTH = 7 * 1000;\r\n\r\nexport const updateGhostStatePhaseTime = action(\r\n  'updateGhostStatePhaseTime',\r\n  (ghost: Ghost) => {\r\n    ghost.statePhaseTimer.advance(ghost.game.lastFrameLength);\r\n  }\r\n);\r\n\r\nexport const updateGhostStatePhase = action(\r\n  'updateGhostStatePhase',\r\n  (ghost: Ghost) => {\r\n    if (!ghost.atTileCenter) {\r\n      return;\r\n    }\r\n\r\n    if (ghost.statePhaseTimer.isTimedOut) {\r\n      ghost.send('PHASE_END');\r\n      ghost.statePhaseTimer.setDuration(getStatePhaseLength(ghost.state));\r\n      ghost.statePhaseTimer.restart();\r\n    }\r\n  }\r\n);\r\n\r\nexport const getStatePhaseLength = (state: StateValue): MilliSeconds => {\r\n  switch (state) {\r\n    case 'chase':\r\n      return CHASE_PHASE_LENGTH;\r\n    case 'scatter':\r\n      return SCATTER_PHASE_LENGTH;\r\n    default:\r\n      // Never ends\r\n      return 9999999999;\r\n  }\r\n};\r\n","import { chooseNewTargetTile } from './chooseNewTargetTile';\r\nimport { chooseNextTile } from './chooseNextTile';\r\nimport {\r\n  TileCoordinates,\r\n  MAZE_WIDTH_IN_SCREEN_COORDINATES,\r\n  MAZE_HEIGHT_IN_SCREEN_COORDINATES,\r\n  assertValidTileCoordinates,\r\n} from './Coordinates';\r\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\r\nimport { Ghost } from './Ghost';\r\nimport { Direction } from './Types';\r\nimport { directionToVector } from './Ways';\r\nimport {\r\n  updateGhostStatePhaseTime,\r\n  updateGhostStatePhase,\r\n} from './updateGhostStatePhase';\r\nimport { Vector } from './Vector';\r\nimport { Game } from './Game';\r\nimport { action } from 'mobx';\r\n\r\nexport const updateGhosts = (game: Game) => {\r\n  for (const ghost of game.ghosts) {\r\n    updateGhost({ ghost });\r\n  }\r\n};\r\n\r\nconst updateGhost = ({ ghost }: { ghost: Ghost }) => {\r\n  if (ghost.ghostPaused) {\r\n    return;\r\n  }\r\n\r\n  updateGhostStatePhaseTime(ghost);\r\n  updateDeadWaitingTimeInBoxLeft(ghost);\r\n\r\n  updateGhostStatePhase(ghost);\r\n\r\n  routeAndMoveGhost(ghost);\r\n};\r\n\r\nconst updateDeadWaitingTimeInBoxLeft = (ghost: Ghost) => {\r\n  if (ghost.dead && ghost.deadWaitingTimeInBoxLeft > 0) {\r\n    ghost.deadWaitingTimeInBoxLeft -= ghost.game.lastFrameLength;\r\n  }\r\n};\r\n\r\nexport const routeAndMoveGhost = (ghost: Ghost) => {\r\n  if (ghost.game.pacMan.dead) {\r\n    return;\r\n  }\r\n\r\n  if (ghost.atTileCenter) {\r\n    reRouteGhost(ghost);\r\n  }\r\n\r\n  moveGhost(ghost);\r\n};\r\n\r\nconst reRouteGhost = (ghost: Ghost) => {\r\n  ghost.targetTile = chooseNewTargetTile(ghost);\r\n  updateDirection(ghost);\r\n  updateSpeed(ghost);\r\n};\r\n\r\nconst updateDirection = (ghost: Ghost) => {\r\n  const newDirection = getNewDirection(ghost);\r\n  ghost.direction = newDirection;\r\n};\r\n\r\nconst updateSpeed = (ghost: Ghost) => {\r\n  const newSpeedFactor = getNewSpeedFactor(ghost);\r\n  ghost.speedFactor = newSpeedFactor;\r\n};\r\n\r\nexport const getNewDirection = (ghost: Ghost): Direction => {\r\n  const currentTile = ghost.tileCoordinates;\r\n  const currentDirection = ghost.direction;\r\n  const targetTile = ghost.targetTile;\r\n  const boxDoorIsOpen = ghost.canPassThroughBoxDoor;\r\n\r\n  const nextTile: TileCoordinates = chooseNextTile({\r\n    currentTile,\r\n    currentDirection,\r\n    targetTile,\r\n    boxDoorIsOpen,\r\n  });\r\n\r\n  return getDirectionFromTileToTile(currentTile, nextTile);\r\n};\r\n\r\nconst moveGhost = (ghost: Ghost) => {\r\n  const vector: Vector = getGhostMovementVector(ghost);\r\n  moveGhostBy(ghost, vector);\r\n};\r\n\r\nconst moveGhostBy = action((ghost: Ghost, vector: Vector) => {\r\n  ghost.screenCoordinates.x =\r\n    (ghost.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\r\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\r\n  ghost.screenCoordinates.y =\r\n    (ghost.screenCoordinates.y + vector.y + MAZE_HEIGHT_IN_SCREEN_COORDINATES) %\r\n    MAZE_HEIGHT_IN_SCREEN_COORDINATES;\r\n\r\n  assertValidTileCoordinates(ghost.tileCoordinates);\r\n});\r\n\r\nconst isInTunnel = (tile: TileCoordinates) =>\r\n  tile.y === 14 && (tile.x >= 22 || tile.x <= 5);\r\n\r\nconst getGhostMovementVector = (ghost: Ghost): Vector => {\r\n  const speed = ghost.game.speed * ghost.speedFactor;\r\n  const velocity = directionToVector(ghost.direction, speed);\r\n  return velocity;\r\n};\r\n\r\nexport const SPEED_FACTOR_HIGH = 2;\r\nexport const SPEED_FACTOR_NORMAL = 1;\r\nexport const SPEED_FACTOR_SLOW = 0.5;\r\n\r\nconst getNewSpeedFactor = (ghost: Ghost): number => {\r\n  if (ghost.dead) {\r\n    return SPEED_FACTOR_HIGH;\r\n  }\r\n  if (isInTunnel(ghost.tileCoordinates) || ghost.state === 'frightened') {\r\n    return SPEED_FACTOR_SLOW;\r\n  }\r\n  return SPEED_FACTOR_NORMAL;\r\n};\r\n","import { action } from 'mobx';\r\nimport { MAZE_WIDTH_IN_SCREEN_COORDINATES } from './Coordinates';\r\nimport { PacMan } from './PacMan';\r\nimport { MilliSeconds } from './Types';\r\nimport { Vector } from './Vector';\r\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\r\n\r\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\r\n\r\nexport const movePacManBy = action((pacMan: PacMan, vector: Vector) => {\r\n  pacMan.screenCoordinates.x =\r\n    (pacMan.screenCoordinates.x + vector.x + MAZE_WIDTH_IN_SCREEN_COORDINATES) %\r\n    MAZE_WIDTH_IN_SCREEN_COORDINATES;\r\n  pacMan.screenCoordinates.y += vector.y;\r\n});\r\n","import { ScreenCoordinates, tileFromScreen } from './Coordinates';\r\nimport { Game } from './Game';\r\nimport { movePacManBy } from './movePacManBy';\r\nimport { PacMan } from './PacMan';\r\nimport { MilliSeconds } from './Types';\r\nimport {\r\n  directionToVector as directionAsVector,\r\n  isTileCenter,\r\n  isWayFreeInDirection,\r\n} from './Ways';\r\nimport { TotalPacManDyingAnimationLength } from './pacManDyingPhase';\r\n\r\nexport const DELAY_TO_REVIVE_PAC_MAN: MilliSeconds = TotalPacManDyingAnimationLength;\r\n\r\nexport const updatePacMan = (game: Game): void => {\r\n  const pacMan = game.pacMan;\r\n  if (pacMan.alive) {\r\n    updateLivingPacMan(pacMan);\r\n  } else {\r\n    updateDeadPacMan(pacMan);\r\n  }\r\n};\r\n\r\nconst updateLivingPacMan = (pacMan: PacMan) => {\r\n  if (isTileCenter(pacMan.screenCoordinates)) {\r\n    const tile = tileFromScreen(pacMan.screenCoordinates);\r\n\r\n    // Change direction if necessary\r\n    if (\r\n      pacMan.direction !== pacMan.nextDirection &&\r\n      isWayFreeInDirection(tile, pacMan.nextDirection)\r\n    ) {\r\n      pacMan.direction = pacMan.nextDirection;\r\n    }\r\n\r\n    // Move\r\n    if (isWayFreeInDirection(tile, pacMan.direction)) {\r\n      movePacMan(pacMan);\r\n    }\r\n  } else {\r\n    movePacMan(pacMan);\r\n  }\r\n};\r\n\r\nconst movePacMan = (pacMan: PacMan): void => {\r\n  const speed = pacMan.game.speed;\r\n  const delta: ScreenCoordinates = directionAsVector(pacMan.direction, speed);\r\n  movePacManBy(pacMan, delta);\r\n};\r\n\r\nconst updateDeadPacMan = (pacMan: PacMan) => {\r\n  if (pacMan.timeSinceDeath >= TotalPacManDyingAnimationLength) {\r\n    revivePacMan(pacMan);\r\n  }\r\n  return;\r\n};\r\n\r\nconst revivePacMan = (pacMan: PacMan) => {\r\n  if (pacMan.extraLivesLeft > 0) {\r\n    pacMan.extraLivesLeft -= 1;\r\n    pacMan.game.revivePacMan();\r\n  }\r\n};\r\n","import { action } from 'mobx';\r\nimport { detectCollisions } from './detectCollisions';\r\nimport { Game } from './Game';\r\nimport { updateGhosts } from './updateGhosts';\r\nimport { updatePacMan } from './updatePacMan';\r\nimport { updateEnergizerTimer } from './updateEnergizerTimer';\r\nimport { updateExternalTimestamp } from './updateExternalTimeStamp';\r\nimport { updateGameTimestamp } from './updateGameTimestamp';\r\n\r\nexport const onAnimationFrame = action(\r\n  'onAnimationFrame',\r\n  ({ game, timestamp }: { game: Game; timestamp: number }) => {\r\n    updateExternalTimestamp({ game, externalTimeStamp: timestamp });\r\n\r\n    if (game.gamePaused) {\r\n      return;\r\n    }\r\n\r\n    updateGameTimestamp(game);\r\n    updateEnergizerTimer(game);\r\n    updatePacMan(game);\r\n    updateGhosts(game);\r\n    detectCollisions(game);\r\n  }\r\n);\r\n","import { Game } from './Game';\r\nimport { MilliSeconds } from './Types';\r\n\r\n// The typical duration of a frame: 1000ms for 60 frames per second = 17ms.\r\nexport const TYPICAL_FRAME_LENGTH: MilliSeconds = 17;\r\n\r\nexport const updateExternalTimestamp = ({\r\n  game,\r\n  externalTimeStamp,\r\n}: {\r\n  game: Game;\r\n  externalTimeStamp: number;\r\n}) => {\r\n  if (game.externalTimeStamp === null) {\r\n    // The very first frame\r\n    // We cannot measure its duration. Therefore we have to make an assumption.\r\n    game.lastFrameLength = TYPICAL_FRAME_LENGTH;\r\n  } else {\r\n    // A later frame.\r\n    // We can calculate its duration.\r\n    game.lastFrameLength = externalTimeStamp - game.externalTimeStamp;\r\n  }\r\n  game.externalTimeStamp = externalTimeStamp;\r\n};\r\n","import { Game } from './Game';\r\n\r\nexport const updateGameTimestamp = (game: Game) => {\r\n  game.timestamp += game.lastFrameLength;\r\n  game.frameCount++;\r\n};\r\n","import { Game } from './Game';\r\n\r\nexport const updateEnergizerTimer = (game: Game) => {\r\n  game.energizerTimer.advance(game.lastFrameLength);\r\n};\r\n","import { useStore } from '../components/StoreContext';\r\nimport { onAnimationFrame } from './onAnimationFrame';\r\nimport { useAnimationLoop } from './useAnimationLoop';\r\n\r\nexport const useGameLoop = () => {\r\n  const store = useStore();\r\n\r\n  const animationStep = (timestamp: number) => {\r\n    const { game } = store;\r\n    onAnimationFrame({ game, timestamp });\r\n  };\r\n\r\n  useAnimationLoop(animationStep);\r\n};\r\n","import { useEffect, useRef } from 'react';\r\nimport { MilliSeconds } from './Types';\r\n\r\ntype AnimationStepFunc = (timestamp: MilliSeconds) => void;\r\n\r\nexport const useAnimationLoop = (animationStep: AnimationStepFunc) => {\r\n  const requestRef = useRef(-1);\r\n\r\n  const animate = (timestamp: number) => {\r\n    animationStep(timestamp);\r\n    requestRef.current = requestAnimationFrame(animate);\r\n  };\r\n\r\n  useEffect(() => {\r\n    requestAnimationFrame(animate);\r\n    return () => {\r\n      cancelAnimationFrame(requestRef.current);\r\n    };\r\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\r\n  }, []);\r\n};\r\n","import { Row } from 'antd';\r\nimport { observer } from 'mobx-react-lite';\r\nimport React, { useEffect } from 'react';\r\nimport styled from 'styled-components/macro';\r\nimport { Board } from '../../components/Board';\r\nimport { DebugView } from './components/DebugView';\r\nimport { ExtraLives } from './components/ExtraLives';\r\nimport { GameOver } from './components/GameOver';\r\nimport { GhostsGameView } from './components/GhostsView';\r\nimport { MazeView } from './components/MazeView';\r\nimport { PacManView } from './components/PacManView';\r\nimport { PillsView } from './components/PillsView';\r\nimport { Score } from './components/Score';\r\nimport { useStore } from '../../components/StoreContext';\r\nimport { useKeyboardActions } from './components/useKeyboardActions';\r\nimport { VSpace } from '../../components/Spacer';\r\nimport { useGameLoop } from '../../model/useGameLoop';\r\n\r\nexport const GamePage: React.FC = observer(() => {\r\n  const store = useStore();\r\n  useEffect(() => {\r\n    store.resetGame();\r\n    return () => {\r\n      store.game.gamePaused = true;\r\n    };\r\n    // eslint-disable-next-line  react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  useGameLoop();\r\n  useKeyboardActions();\r\n\r\n  return (\r\n    <Layout data-testid=\"GamePage\">\r\n      <ScoreArea>\r\n        <Row justify=\"center\">\r\n          <Score />\r\n        </Row>\r\n        <VSpace size=\"small\" />\r\n      </ScoreArea>\r\n\r\n      <EmptyArea />\r\n\r\n      <BoardArea>\r\n        <Board>\r\n          <MazeView />\r\n          <PillsView />\r\n          <PacManView />\r\n          <GhostsGameView />\r\n          <GameOver />\r\n        </Board>\r\n        <VSpace size=\"large\" />\r\n        <Row justify=\"center\">\r\n          <ExtraLives />\r\n        </Row>\r\n        <Row justify=\"center\">\r\n          <button\r\n            className=\"arrow-bt\"\r\n            onClick={() => {\r\n              store.game.pacMan.nextDirection = 'LEFT';\r\n            }}\r\n          >\r\n            LEFT\r\n          </button>\r\n          <button\r\n            className=\"arrow-bt\"\r\n            onClick={() => {\r\n              store.game.pacMan.nextDirection = 'UP';\r\n            }}\r\n          >\r\n            UP\r\n          </button>\r\n          <button\r\n            className=\"arrow-bt\"\r\n            onClick={() => {\r\n              store.game.pacMan.nextDirection = 'DOWN';\r\n            }}\r\n          >\r\n            DOWN\r\n          </button>\r\n          <button\r\n            className=\"arrow-bt\"\r\n            onClick={() => {\r\n              store.game.pacMan.nextDirection = 'RIGHT';\r\n            }}\r\n          >\r\n            RIGHT\r\n          </button>\r\n        </Row>\r\n      </BoardArea>\r\n\r\n      {/* <DebugArea>\r\n        <DebugView />\r\n      </DebugArea> */}\r\n    </Layout>\r\n  );\r\n});\r\n\r\nconst Layout = styled.div`\r\n  margin-left: 16px;\r\n  margin-right: 16px;\r\n\r\n  display: grid;\r\n\r\n  @media (min-width: 1280px) {\r\n    grid-template-columns: 1fr 1fr;\r\n    justify-items: center;\r\n  }\r\n  @media (max-width: 1280px) {\r\n    grid-template-columns: 1fr;\r\n    justify-items: center;\r\n  }\r\n`;\r\n\r\nconst ScoreArea = styled.div``;\r\n\r\nconst EmptyArea = styled.div``;\r\n\r\nconst BoardArea = styled.div``;\r\n\r\nconst DebugArea = styled.div`\r\n  @media (max-width: 1280px) {\r\n    display: none;\r\n  }\r\n`;\r\n","import { useCallback, useEffect } from 'react';\r\nimport { useStore } from '../../../components/StoreContext';\r\n\r\n/* eslint-disable  react-hooks/exhaustive-deps */\r\nexport const useKeyboardActions = (): void => {\r\n  const store = useStore();\r\n\r\n  const onKeyDown = useCallback((event: KeyboardEvent) => {\r\n    const { game } = store;\r\n    const pressedKey = event.key;\r\n    const pacMan = game.pacMan;\r\n    switch (pressedKey) {\r\n      case 'ArrowLeft':\r\n        pacMan.nextDirection = 'LEFT';\r\n        break;\r\n      case 'ArrowRight':\r\n        pacMan.nextDirection = 'RIGHT';\r\n        break;\r\n      case 'ArrowUp':\r\n        pacMan.nextDirection = 'UP';\r\n        break;\r\n      case 'ArrowDown':\r\n        pacMan.nextDirection = 'DOWN';\r\n        break;\r\n      case ' ':\r\n        game.gamePaused = !game.gamePaused;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    document.addEventListener('keydown', onKeyDown);\r\n\r\n    return () => {\r\n      document.removeEventListener('keydown', onKeyDown);\r\n    };\r\n  }, []);\r\n};\r\n","import React, { FC, useState } from 'react';\r\nimport {\r\n  SCREEN_TILE_SIZE,\r\n  TileCoordinates,\r\n  ScreenCoordinates,\r\n} from '../model/Coordinates';\r\n\r\nimport './Grid.css';\r\nimport { waysMatrix, getPillsMatrix } from '../model/MazeData';\r\n\r\nconst ROWS = 31;\r\nconst COLUMNS = 28;\r\n\r\nexport const GridWithHoverCoordinates: FC<{\r\n  screenCoordinates: ScreenCoordinates;\r\n  onClick?: (\r\n    coordinates: TileCoordinates,\r\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void; // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n}> = ({ screenCoordinates, onClick }) => {\r\n  const [coordinates, setCoordinates] = useState<TileCoordinates | null>(null);\r\n  const pillsMatrix = getPillsMatrix();\r\n  const { x, y } = screenCoordinates;\r\n  return (\r\n    <>\r\n      <Grid x={x} y={y} onHover={setCoordinates} onClick={onClick} />\r\n      <div\r\n        style={{\r\n          position: 'absolute',\r\n          left: `${x}px`,\r\n          top: `${y + ROWS * SCREEN_TILE_SIZE}px`,\r\n          height: '20px',\r\n        }}\r\n      >\r\n        {coordinates &&\r\n          `${coordinates.x} / ${coordinates.y} - ways layer id: ${\r\n            waysMatrix[coordinates.y][coordinates.x]\r\n          } - pills layer id: ${\r\n            pillsMatrix[coordinates.y][coordinates.x]\r\n          }`}{' '}\r\n        &nbsp;\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport const Grid: FC<{\r\n  x: number;\r\n  y: number;\r\n  onClick?: (\r\n    coordinates: TileCoordinates,\r\n    event: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n  ) => void;\r\n  onHover: (coordinates: TileCoordinates | null) => void;\r\n}> = ({ x, y, onClick, onHover }) => {\r\n  return (\r\n    <div\r\n      className={'Grid'}\r\n      style={{\r\n        position: 'absolute',\r\n        left: `${x}px`,\r\n        top: `${y}px`,\r\n        gridTemplateColumns: `repeat(${COLUMNS}, ${SCREEN_TILE_SIZE}px)`,\r\n        gridTemplateRows: `repeat(${ROWS}, ${SCREEN_TILE_SIZE}PX)`,\r\n      }}\r\n    >\r\n      {Array(ROWS)\r\n        .fill(null)\r\n        .map((_, rowIndex) =>\r\n          Array.from({ length: COLUMNS }).map((_, columnIndex) => (\r\n            <div\r\n              className=\"GridCell\"\r\n              key={`${columnIndex}/${rowIndex}`}\r\n              onClick={(\r\n                event: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n              ) => {\r\n                if (onClick) {\r\n                  onClick({ x: columnIndex, y: rowIndex }, event);\r\n                }\r\n              }}\r\n              onMouseEnter={() => onHover({ x: columnIndex, y: rowIndex })}\r\n              onMouseLeave={() => onHover(null)}\r\n            />\r\n          ))\r\n        )}\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { GridWithHoverCoordinates } from '../../components/Grid';\r\nimport { PacManSprite } from '../GamePage/components/PacManView';\r\nimport { BasicPillHitBox, PillsView } from '../GamePage/components/PillsView';\r\nimport { Sprite } from '../../components/Sprite';\r\nimport {\r\n  screenFromTileCoordinate,\r\n  SCREEN_TILE_CENTER,\r\n} from '../../model/Coordinates';\r\nimport styled from 'styled-components/macro';\r\nimport { Row, Col } from 'antd';\r\n\r\nexport const MazePage: React.FC = () => {\r\n  return (\r\n    <Layout data-testid=\"MazePage\">\r\n      <Row justify=\"space-around\">\r\n        <Col flex=\"562px\">\r\n          <RelativeAbsoluteLayout>\r\n            <Sprite\r\n              className=\"Sprite-maze\"\r\n              name=\"maze-state-empty\"\r\n              x={0}\r\n              y={0}\r\n            />\r\n            <GridWithHoverCoordinates screenCoordinates={{ x: 0, y: 0 }} />\r\n            <PillsView />\r\n          </RelativeAbsoluteLayout>\r\n        </Col>\r\n\r\n        <Col flex=\"562px\">\r\n          <RelativeAbsoluteLayout>\r\n            <Sprite\r\n              className=\"Sprite-maze\"\r\n              name=\"maze-state-empty\"\r\n              x={0}\r\n              y={0}\r\n            />\r\n            <GridWithHoverCoordinates screenCoordinates={{ x: 0, y: 0 }} />\r\n            <Sprite x={20 * 1} y={20 * 1} name=\"basic-pill\"></Sprite>\r\n            <Sprite x={20 * 1} y={20 * 3} name=\"energizer\"></Sprite>\r\n            <Sprite x={20 * 6} y={20 * 10} name=\"energizer\"></Sprite>\r\n            <PacManSprite\r\n              direction=\"RIGHT\"\r\n              pacManAnimationPhase={1}\r\n              x={screenFromTileCoordinate(1) + SCREEN_TILE_CENTER}\r\n              y={screenFromTileCoordinate(4) + SCREEN_TILE_CENTER}\r\n            />\r\n            <BasicPillHitBox />\r\n          </RelativeAbsoluteLayout>\r\n        </Col>\r\n      </Row>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nconst Layout = styled.div`\r\n  margin: 32px;\r\n`;\r\n\r\nconst RelativeAbsoluteLayout = styled.div`\r\n  position: relative;\r\n`;\r\n","import { Ghost } from './Ghost';\r\nimport { DIRECTION_TO_OPPOSITE_DIRECTION } from './Ways';\r\n\r\nexport const changeDirectionToOpposite = (ghost: Ghost) => {\r\n  ghost.direction = DIRECTION_TO_OPPOSITE_DIRECTION[ghost.direction];\r\n};\r\n","import { TileCoordinates } from './Coordinates';\r\nimport { Direction } from './Types';\r\nimport { isEqual } from 'lodash';\r\nimport { chooseNextTile } from './chooseNextTile';\r\nimport { getDirectionFromTileToTile } from './getDirectionFromTileToTile';\r\n\r\nexport const findWayPoints = (\r\n  origin: TileCoordinates,\r\n  destination: TileCoordinates,\r\n  currentDirection: Direction,\r\n  boxDoorIsOpen: boolean\r\n): TileCoordinates[] | null => {\r\n  const way: TileCoordinates[] = [origin];\r\n  let currentTile = origin;\r\n  let workingDirection = currentDirection;\r\n  while (!isEqual(currentTile, destination)) {\r\n    const nextTile = chooseNextTile({\r\n      currentTile,\r\n      currentDirection: workingDirection,\r\n      targetTile: destination,\r\n      boxDoorIsOpen,\r\n    });\r\n    // Prevent endless iteration\r\n    if (way.some(wayPoint => isEqual(wayPoint, nextTile))) {\r\n      return way;\r\n    }\r\n    way.push(nextTile);\r\n    workingDirection = getDirectionFromTileToTile(\r\n      currentTile,\r\n      nextTile\r\n    ) as Direction;\r\n    currentTile = nextTile;\r\n  }\r\n  return way;\r\n};\r\n","/* eslint-disable @typescript-eslint/ban-types */\r\n\r\nimport { Machine, interpret, State } from 'xstate';\r\n\r\nexport const INITIAL_GHOST_STATE = 'scatter';\r\n\r\ninterface GhostEventHandler {\r\n  onScatterToChase(): void;\r\n  onChaseToScatter(): void;\r\n  onDead(): void;\r\n}\r\n\r\ntype GhostContext = {};\r\n\r\ninterface GhostStateSchema {\r\n  states: {\r\n    chase: {};\r\n    scatter: {};\r\n    frightened: {};\r\n    dead: {};\r\n  };\r\n}\r\n\r\nexport type GhostEventType =\r\n  | 'RESET'\r\n  | 'ENERGIZER_EATEN'\r\n  | 'ENERGIZER_TIMED_OUT'\r\n  | 'PHASE_END'\r\n  | 'COLLISION_WITH_PAC_MAN'\r\n  | 'REVIVED';\r\n\r\ntype GhostEvent = { type: GhostEventType };\r\n\r\nexport type GhostState = State<GhostContext, GhostEvent, GhostStateSchema, any>;\r\n\r\nconst GhostStateChart = Machine<GhostContext, GhostStateSchema, GhostEvent>({\r\n  id: 'ghost',\r\n  initial: INITIAL_GHOST_STATE,\r\n  on: {\r\n    RESET: INITIAL_GHOST_STATE,\r\n  },\r\n  states: {\r\n    chase: {\r\n      on: {\r\n        ENERGIZER_EATEN: 'frightened',\r\n        PHASE_END: {\r\n          target: 'scatter',\r\n          actions: 'onChaseToScatter',\r\n        },\r\n        COLLISION_WITH_PAC_MAN: {\r\n          target: 'scatter',\r\n        },\r\n      },\r\n    },\r\n    scatter: {\r\n      on: {\r\n        ENERGIZER_EATEN: 'frightened',\r\n        PHASE_END: {\r\n          target: 'chase',\r\n          actions: 'onScatterToChase',\r\n        },\r\n        COLLISION_WITH_PAC_MAN: {\r\n          target: 'scatter',\r\n        },\r\n      },\r\n    },\r\n    frightened: {\r\n      on: {\r\n        ENERGIZER_TIMED_OUT: 'chase',\r\n        COLLISION_WITH_PAC_MAN: {\r\n          target: 'dead',\r\n          actions: 'onDead',\r\n        },\r\n      },\r\n    },\r\n    dead: {\r\n      on: {\r\n        REVIVED: 'scatter',\r\n        ENERGIZER_TIMED_OUT: 'scatter',\r\n      },\r\n    },\r\n  },\r\n});\r\n\r\nexport const makeGhostStateChart = (eventHandler: GhostEventHandler) => {\r\n  const extended = GhostStateChart.withConfig({\r\n    actions: {\r\n      onScatterToChase: eventHandler.onScatterToChase,\r\n      onChaseToScatter: eventHandler.onChaseToScatter,\r\n      onDead: eventHandler.onDead,\r\n    },\r\n  });\r\n  const stateChart = interpret(extended);\r\n  return stateChart;\r\n};\r\n","import { MilliSeconds } from './Types';\r\nimport { observable, computed, action } from 'mobx';\r\n\r\nexport type TimerCallback = () => void;\r\n\r\nexport class TimeoutTimer {\r\n  duration: MilliSeconds;\r\n  readonly onTimedOut: TimerCallback | null;\r\n\r\n  @observable\r\n  running: boolean;\r\n\r\n  @observable\r\n  timeSpent: MilliSeconds;\r\n\r\n  constructor(duration: MilliSeconds, onTimedOut: TimerCallback | null = null) {\r\n    this.duration = duration;\r\n    this.onTimedOut = onTimedOut;\r\n    this.running = false;\r\n    this.timeSpent = 0;\r\n  }\r\n\r\n  @action\r\n  setDuration(duration: MilliSeconds) {\r\n    this.duration = duration;\r\n  }\r\n\r\n  @action.bound\r\n  start() {\r\n    this.running = true;\r\n    this.timeSpent = 0;\r\n  }\r\n\r\n  @action\r\n  advance(timePassed: MilliSeconds) {\r\n    if (!this.running) {\r\n      return;\r\n    }\r\n    this.timeSpent += timePassed;\r\n    if (this.isTimedOut) {\r\n      this.onTimedOut?.();\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  @action\r\n  stop() {\r\n    this.running = false;\r\n  }\r\n\r\n  restart() {\r\n    this.stop();\r\n    this.start();\r\n  }\r\n\r\n  @computed\r\n  get timeLeft() {\r\n    return this.duration - this.timeSpent;\r\n  }\r\n\r\n  @computed\r\n  get isTimedOut() {\r\n    return this.timeSpent >= this.duration;\r\n  }\r\n}\r\n","import { action, computed, observable } from 'mobx';\r\nimport { changeDirectionToOpposite } from './changeDirectionToOpposite';\r\nimport {\r\n  ScreenCoordinates,\r\n  screenFromTile,\r\n  TileCoordinates,\r\n  tileFromScreen,\r\n} from './Coordinates';\r\nimport { findWayPoints } from './findWayPoints';\r\nimport { Game } from './Game';\r\nimport {\r\n  GhostEventType,\r\n  makeGhostStateChart,\r\n  GhostState,\r\n} from './GhostStateChart';\r\nimport { Direction, MilliSeconds } from './Types';\r\nimport {\r\n  isTileInBox as isTileInBoxWalls,\r\n  isTileCenter,\r\n  isTileInBoxSpace,\r\n} from './Ways';\r\nimport { StateValue } from 'xstate';\r\nimport { TimeoutTimer } from './TimeoutTimer';\r\nimport { getStatePhaseLength } from './updateGhostStatePhase';\r\n\r\nexport type GhostNumber = 0 | 1 | 2 | 3;\r\nexport const GhostNumbers: GhostNumber[] = [0, 1, 2, 3];\r\nexport type GhostAnimationPhase = 0 | 1;\r\nexport const GhostAnimationPhases: GhostAnimationPhase[] = [0, 1];\r\nexport type FrightenedGhostTime = 0 | 1;\r\nexport const FrightenedGhostTimes: FrightenedGhostTime[] = [0, 1];\r\n\r\nconst FRIGHTENED_ABOUT_TO_END_DURATION: MilliSeconds = 3000;\r\nconst DEAD_WAITING_IN_BOX_DURATION: MilliSeconds = 3000;\r\n\r\nexport const KILL_GHOST_SCORE = [0, 100, 200, 400, 800, 1600, 3200];\r\n\r\nexport class Ghost {\r\n  constructor(game: Game) {\r\n    this.game = game;\r\n\r\n    this.stateChart.onTransition(this.handleStateTransition);\r\n    this.stateChart.start();\r\n  }\r\n\r\n  @action.bound\r\n  handleStateTransition(state: GhostState) {\r\n    if (!state.changed) {\r\n      return;\r\n    }\r\n    this.stateChartState = state;\r\n    this.stateChanges++;\r\n  }\r\n\r\n  stateChart = makeGhostStateChart({\r\n    onScatterToChase: this.onScatterToChase,\r\n    onChaseToScatter: this.onChaseToScatter,\r\n    onDead: this.onDead,\r\n  });\r\n\r\n  @action.bound\r\n  onDead() {\r\n    this.game.killedGhosts++;\r\n    this.game.score += KILL_GHOST_SCORE[this.game.killedGhosts];\r\n    this.deadWaitingTimeInBoxLeft = DEAD_WAITING_IN_BOX_DURATION;\r\n  }\r\n\r\n  @action.bound\r\n  onScatterToChase() {\r\n    changeDirectionToOpposite(this);\r\n  }\r\n\r\n  @action.bound\r\n  onChaseToScatter() {\r\n    changeDirectionToOpposite(this);\r\n  }\r\n\r\n  @observable.ref\r\n  stateChartState: GhostState = this.stateChart.state;\r\n\r\n  @computed\r\n  get state(): StateValue {\r\n    return this.stateChartState.value;\r\n  }\r\n\r\n  @observable\r\n  stateChanges = 0;\r\n\r\n  @computed\r\n  get dead() {\r\n    return this.stateChartState.matches('dead');\r\n  }\r\n\r\n  @computed\r\n  get alive() {\r\n    return !this.dead;\r\n  }\r\n\r\n  @computed get frightened(): boolean {\r\n    return this.stateChartState.matches('frightened');\r\n  }\r\n\r\n  name = 'ghost name';\r\n\r\n  send(event: GhostEventType) {\r\n    this.stateChart.send(event);\r\n  }\r\n\r\n  @observable\r\n  ghostPaused = true;\r\n\r\n  game: Game;\r\n\r\n  @observable\r\n  ghostNumber: GhostNumber = 0;\r\n\r\n  color = 'ghost color';\r\n  colorCode = '#00ffff';\r\n\r\n  @observable\r\n  screenCoordinates: ScreenCoordinates = {\r\n    x: 16,\r\n    y: 16,\r\n  };\r\n\r\n  @computed\r\n  get atTileCenter(): boolean {\r\n    return isTileCenter(this.screenCoordinates);\r\n  }\r\n\r\n  @observable\r\n  speedFactor = 1;\r\n\r\n  @action\r\n  setTileCoordinates(tile: TileCoordinates) {\r\n    this.screenCoordinates = screenFromTile(tile);\r\n  }\r\n\r\n  @computed\r\n  get tileCoordinates(): TileCoordinates {\r\n    return tileFromScreen(this.screenCoordinates);\r\n  }\r\n\r\n  @computed\r\n  get animationPhase(): GhostAnimationPhase {\r\n    return Math.round((this.game.timestamp + this.ghostNumber * 100) / 300) %\r\n      2 ===\r\n      0\r\n      ? 0\r\n      : 1;\r\n  }\r\n\r\n  @computed\r\n  get frightenedAboutToEnd(): boolean {\r\n    return this.game.energizerTimer.timeLeft < FRIGHTENED_ABOUT_TO_END_DURATION;\r\n  }\r\n\r\n  @observable\r\n  deadWaitingTimeInBoxLeft: MilliSeconds = 0;\r\n\r\n  @computed\r\n  get frightenedGhostTime(): FrightenedGhostTime {\r\n    if (!this.frightenedAboutToEnd) {\r\n      return 0;\r\n    }\r\n    // Blink every 0.5 seconds\r\n    return this.game.timestamp % 1000 < 500 ? 0 : 1;\r\n  }\r\n\r\n  @observable\r\n  direction: Direction = 'LEFT';\r\n\r\n  @observable\r\n  targetTile: TileCoordinates = { x: 1, y: 1 };\r\n\r\n  @computed\r\n  get wayPoints(): TileCoordinates[] | null {\r\n    return findWayPoints(\r\n      this.tileCoordinates,\r\n      this.targetTile,\r\n      this.direction,\r\n      this.canPassThroughBoxDoor\r\n    );\r\n  }\r\n\r\n  statePhaseTimer = new TimeoutTimer(3000);\r\n\r\n  @computed\r\n  get isInsideBoxWalls(): boolean {\r\n    return isTileInBoxWalls(this.tileCoordinates);\r\n  }\r\n\r\n  @computed\r\n  get isOutsideBoxSpace() {\r\n    return !isTileInBoxSpace(this.tileCoordinates);\r\n  }\r\n\r\n  @computed\r\n  get canPassThroughBoxDoor(): boolean {\r\n    if (this.alive) {\r\n      if (this.isInsideBoxWalls) {\r\n        if (this.game.timestamp > this.initialWaitingTimeInBox) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.dead) {\r\n      if (this.isOutsideBoxSpace) {\r\n        return true;\r\n      }\r\n\r\n      // Dead && Inside box\r\n      if (this.deadWaitingTimeInBoxLeft <= 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  @action\r\n  resetGhost() {\r\n    this.ghostPaused = false;\r\n    this.send('RESET');\r\n    this.statePhaseTimer.setDuration(getStatePhaseLength(this.state));\r\n    this.statePhaseTimer.restart();\r\n  }\r\n\r\n  initialWaitingTimeInBox = 0;\r\n}\r\n","import React, { useEffect, useState } from 'react';\r\nimport {\r\n  PacManAnimationPhase,\r\n  PacManAnimationPhases,\r\n  PacManSprite,\r\n  DyingPacManSprite,\r\n} from '../GamePage/components/PacManView';\r\nimport {\r\n  GhostSprite,\r\n  DeadGhostSprite,\r\n  FrightenedGhostSprite,\r\n} from '../GamePage/components/GhostsView';\r\nimport { Directions, Direction } from '../../model/Types';\r\nimport { Sprite } from '../../components/Sprite';\r\nimport {\r\n  GhostAnimationPhases,\r\n  GhostNumbers,\r\n  GhostAnimationPhase,\r\n  GhostNumber,\r\n  FrightenedGhostTimes,\r\n} from '../../model/Ghost';\r\nimport styled from 'styled-components/macro';\r\nimport {\r\n  PacManDyingPhaseCount,\r\n  PacManDyingPhase,\r\n  PacManDyingPhases,\r\n} from '../../model/pacManDyingPhase';\r\n\r\nexport const SpritePage: React.FC = () => {\r\n  const [phaseCounter, setPhaseCounter] = useState<number>(0);\r\n  const [directionIndex, setDirectionIndex] = useState<number>(0);\r\n  const pacManPhase = (phaseCounter %\r\n    PacManAnimationPhases.length) as PacManAnimationPhase;\r\n  const ghostPhase = (phaseCounter %\r\n    GhostAnimationPhases.length) as GhostAnimationPhase;\r\n  const dyingPacManAnimationPhase = (phaseCounter %\r\n    PacManDyingPhaseCount) as PacManDyingPhase;\r\n\r\n  useEffect(() => {\r\n    const timerId = setInterval(() => {\r\n      setPhaseCounter((phaseCounter: number) => phaseCounter + 1);\r\n    }, 300);\r\n    return () => {\r\n      clearInterval(timerId);\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const timerId = setInterval(() => {\r\n      setDirectionIndex((directionIndex: number) =>\r\n        directionIndex === 3 ? 0 : directionIndex + 1\r\n      );\r\n    }, 1000);\r\n    return () => {\r\n      clearInterval(timerId);\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n  const direction = Directions[directionIndex];\r\n  return (\r\n    <Layout className=\"SpriteTestPage\" data-testid=\"SpritePage\">\r\n      {GhostNumbers.map((ghostNumber: GhostNumber) =>\r\n        Directions.map((direction: Direction, directionIndex: number) =>\r\n          GhostAnimationPhases.map((ghostPhase: GhostAnimationPhase) => (\r\n            <GhostSprite\r\n              key={`${ghostPhase}-${direction}-${ghostPhase}`}\r\n              direction={direction}\r\n              ghostAnimationPhase={ghostPhase}\r\n              x={directionIndex * 160 + ghostPhase * 80}\r\n              y={ghostNumber * 60}\r\n              ghostNumber={ghostNumber}\r\n            />\r\n          ))\r\n        )\r\n      )}\r\n\r\n      {FrightenedGhostTimes.map(frightenedGhostTime =>\r\n        GhostAnimationPhases.map(ghostAnimationPhase => (\r\n          <FrightenedGhostSprite\r\n            key={`${ghostAnimationPhase}-${frightenedGhostTime}`}\r\n            ghostAnimationPhase={ghostAnimationPhase}\r\n            frightenedGhostTime={frightenedGhostTime}\r\n            x={ghostAnimationPhase * 80 + frightenedGhostTime * 160}\r\n            y={4 * 60}\r\n          />\r\n        ))\r\n      )}\r\n\r\n      {Directions.map((direction: Direction, directionIndex: number) => (\r\n        <DeadGhostSprite\r\n          key={directionIndex}\r\n          direction={direction}\r\n          x={directionIndex * 80}\r\n          y={5 * 60}\r\n        />\r\n      ))}\r\n\r\n      {Directions.map((direction: Direction, directionIndex: number) =>\r\n        PacManAnimationPhases.map((pacManPhase: PacManAnimationPhase) => (\r\n          <PacManSprite\r\n            key={pacManPhase}\r\n            direction={direction}\r\n            pacManAnimationPhase={pacManPhase}\r\n            x={directionIndex * 160 + pacManPhase * 80}\r\n            y={6 * 60}\r\n          />\r\n        ))\r\n      )}\r\n\r\n      {PacManDyingPhases.map(dyingPacManPhase => (\r\n        <DyingPacManSprite\r\n          key={dyingPacManPhase}\r\n          dyingPacManAnimationPhase={dyingPacManPhase}\r\n          x={dyingPacManPhase * 45}\r\n          y={7 * 60}\r\n        />\r\n      ))}\r\n\r\n      {GhostNumbers.map(ghostNumber => (\r\n        <GhostSprite\r\n          key={ghostNumber}\r\n          direction={direction}\r\n          ghostAnimationPhase={ghostPhase}\r\n          x={ghostNumber * 80}\r\n          y={8 * 60}\r\n          ghostNumber={ghostNumber}\r\n        />\r\n      ))}\r\n      <FrightenedGhostSprite\r\n        ghostAnimationPhase={ghostPhase}\r\n        frightenedGhostTime={0}\r\n        x={4 * 80}\r\n        y={8 * 60}\r\n      />\r\n      <FrightenedGhostSprite\r\n        ghostAnimationPhase={ghostPhase}\r\n        frightenedGhostTime={1}\r\n        x={5 * 80}\r\n        y={8 * 60}\r\n      />\r\n\r\n      <DeadGhostSprite direction={direction} x={6 * 80} y={8 * 60} />\r\n\r\n      <PacManSprite\r\n        direction={direction}\r\n        pacManAnimationPhase={pacManPhase}\r\n        x={7 * 80}\r\n        y={8 * 60}\r\n      />\r\n\r\n      <DyingPacManSprite\r\n        dyingPacManAnimationPhase={dyingPacManAnimationPhase}\r\n        x={0 + 0 * 80}\r\n        y={9 * 60}\r\n      />\r\n\r\n      <Sprite x={0 + 0 * 80} y={10 * 60} name=\"basic-pill\"></Sprite>\r\n      <Sprite x={0 + 1 * 80} y={10 * 60} name=\"energizer\"></Sprite>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nconst Layout = styled.div`\r\n  position: relative;\r\n  margin-top: 50px;\r\n  margin-left: 100px;\r\n  width: 800px;\r\n  height: 600px;\r\n`;\r\n","/* eslint-disable react/no-unescaped-entities */\r\nimport React from 'react';\r\nimport { Sprite } from '../../components/Sprite';\r\nimport { GridWithHoverCoordinates } from '../../components/Grid';\r\n\r\nimport { PacManSprite } from '../GamePage/components/PacManView';\r\nimport { GhostSprite } from '../GamePage/components/GhostsView';\r\nimport {\r\n  screenFromTileCoordinate,\r\n  TileCoordinates,\r\n  SCREEN_TILE_CENTER,\r\n} from '../../model/Coordinates';\r\nimport { useLocalStore, observer } from 'mobx-react-lite';\r\nimport { action } from 'mobx';\r\n\r\nimport { WayPoints } from './WayPoints';\r\nimport { findWayPoints } from '../../model/findWayPoints';\r\nimport styled from 'styled-components/macro';\r\nimport { Row } from 'antd';\r\n\r\nexport const WayFindingPage = observer(() => {\r\n  const localStore = useLocalStore(() => ({\r\n    origin: { x: 1, y: 1 } as TileCoordinates,\r\n    destination: { x: 6, y: 15 } as TileCoordinates,\r\n    setOrigin: action((value: TileCoordinates) => {\r\n      localStore.origin = value;\r\n    }),\r\n    setDestination: action((value: TileCoordinates) => {\r\n      localStore.destination = value;\r\n    }),\r\n  }));\r\n\r\n  const wayPoints =\r\n    findWayPoints(localStore.origin, localStore.destination, 'RIGHT', true) ??\r\n    [];\r\n\r\n  return (\r\n    <Layout data-testid=\"WayfindingPage\">\r\n      <Row justify=\"center\">\r\n        <RelativeAbsoluteLayout>\r\n          <Sprite className=\"Sprite-maze\" name=\"maze-state-empty\" x={0} y={0} />\r\n\r\n          <GridWithHoverCoordinates\r\n            screenCoordinates={{ x: 0, y: 0 }}\r\n            onClick={(\r\n              coordinates: TileCoordinates,\r\n              event: React.MouseEvent<HTMLDivElement, MouseEvent>\r\n            ) => {\r\n              if (event.shiftKey) {\r\n                localStore.setOrigin(coordinates);\r\n              } else {\r\n                localStore.setDestination(coordinates);\r\n              }\r\n            }}\r\n          />\r\n\r\n          <GhostSprite\r\n            direction=\"RIGHT\"\r\n            ghostAnimationPhase={1}\r\n            x={\r\n              screenFromTileCoordinate(localStore.origin.x - 1) +\r\n              SCREEN_TILE_CENTER\r\n            }\r\n            y={\r\n              screenFromTileCoordinate(localStore.origin.y - 1) +\r\n              SCREEN_TILE_CENTER\r\n            }\r\n            ghostNumber={0}\r\n          />\r\n\r\n          <PacManSprite\r\n            direction=\"RIGHT\"\r\n            pacManAnimationPhase={1}\r\n            x={\r\n              screenFromTileCoordinate(localStore.destination.x - 1) +\r\n              SCREEN_TILE_CENTER\r\n            }\r\n            y={\r\n              screenFromTileCoordinate(localStore.destination.y - 1) +\r\n              SCREEN_TILE_CENTER\r\n            }\r\n            style={{}}\r\n          />\r\n\r\n          <WayPoints wayPoints={wayPoints} color=\"#e2a12b\"></WayPoints>\r\n          <div style={{ position: 'absolute', top: 660, width: '300px' }}>\r\n            Click sets pac man's position\r\n            <br /> Shift-Click sets ghost position\r\n          </div>\r\n        </RelativeAbsoluteLayout>\r\n      </Row>\r\n    </Layout>\r\n  );\r\n});\r\n\r\nconst Layout = styled.div`\r\n  margin-top: 32px;\r\n`;\r\n\r\nconst RelativeAbsoluteLayout = styled.div`\r\n  position: relative;\r\n  width: 560px;\r\n`;\r\n","import React from 'react';\r\nimport { Route, Switch } from 'react-router-dom';\r\n\r\nimport { GamePage } from './pages/GamePage/GamePage';\r\nimport { MazePage } from './pages/MazePage/MazePage';\r\nimport { SpritePage } from './pages/SpritePage/SpritePage';\r\nimport { WayFindingPage } from './pages/WayFindingPage/WayFindingPage';\r\n\r\nexport const Routes: React.FC = () => {\r\n  return (\r\n    <Switch>\r\n      <Route path=\"/\" exact>\r\n        <GamePage />\r\n      </Route>\r\n      <Route path=\"/sprites\">\r\n        <SpritePage />\r\n      </Route>\r\n      <Route path=\"/maze\">\r\n        <MazePage />\r\n      </Route>\r\n      <Route path=\"/way-finding\">\r\n        <WayFindingPage />\r\n      </Route>\r\n    </Switch>\r\n  );\r\n};\r\n","import { Menu } from 'antd';\r\nimport React from 'react';\r\nimport { useHistory, useLocation } from 'react-router-dom';\r\nimport styled from 'styled-components';\r\nimport { VSpace } from './Spacer';\r\n\r\nexport const AppMenu: React.FC = () => {\r\n  const location = useLocation();\r\n  const history = useHistory();\r\n  const selectedKey = location.pathname;\r\n  return (\r\n    <div className=\"AppMenu\">\r\n      <MenuStyled\r\n        mode=\"horizontal\"\r\n        onClick={event => {\r\n          history.push(event.key.toString());\r\n        }}\r\n        selectedKeys={[selectedKey]}\r\n      >\r\n        <Menu.Item key=\"/\">Home</Menu.Item>\r\n        <Menu.Item key=\"/sprites\">Sprites</Menu.Item>\r\n        <Menu.Item key=\"/maze\">Maze</Menu.Item>\r\n        <Menu.Item key=\"/way-finding\">Way Finding</Menu.Item>\r\n      </MenuStyled>\r\n      <VSpace size=\"large\" />\r\n    </div>\r\n  );\r\n};\r\n\r\nconst MenuStyled = styled(Menu)`\r\n  background-color: inherit;\r\n  border-bottom: none;\r\n  margin-left: 4px;\r\n\r\n  .ant-menu-item {\r\n    color: white;\r\n  }\r\n`;\r\n","import { Game } from './Game';\r\nimport { Ghost } from './Ghost';\r\n\r\nexport const resetGhosts = (ghosts: Ghost[]) => {\r\n  ghosts[0].setTileCoordinates({ x: 12, y: 14 });\r\n  ghosts[0].direction = 'LEFT';\r\n  ghosts[1].setTileCoordinates({ x: 13, y: 14 });\r\n  ghosts[1].direction = 'RIGHT';\r\n  ghosts[2].setTileCoordinates({ x: 14, y: 14 });\r\n  ghosts[3].direction = 'LEFT';\r\n  ghosts[3].setTileCoordinates({ x: 15, y: 14 });\r\n  ghosts[3].direction = 'RIGHT';\r\n\r\n  for (const ghost of ghosts) {\r\n    ghost.resetGhost();\r\n  }\r\n};\r\n\r\nexport const makeGhosts = (game: Game): Ghost[] => {\r\n  const ghosts: Ghost[] = [\r\n    new Ghost(game),\r\n    new Ghost(game),\r\n    new Ghost(game),\r\n    new Ghost(game),\r\n  ];\r\n\r\n  ghosts[0].ghostNumber = 0;\r\n  ghosts[0].name = 'Blinky';\r\n  ghosts[0].color = 'red';\r\n  ghosts[0].colorCode = '#ff0000';\r\n  ghosts[0].initialWaitingTimeInBox = 1000;\r\n\r\n  ghosts[1].ghostNumber = 1;\r\n  ghosts[1].name = 'Pinky';\r\n  ghosts[1].color = 'pink';\r\n  ghosts[1].colorCode = '#fcb5ff';\r\n  ghosts[1].initialWaitingTimeInBox = 1300;\r\n\r\n  ghosts[2].ghostNumber = 2;\r\n  ghosts[2].name = 'Inky';\r\n  ghosts[2].color = 'blue';\r\n  ghosts[2].colorCode = '#00ffff';\r\n  ghosts[2].initialWaitingTimeInBox = 1600;\r\n\r\n  ghosts[3].ghostNumber = 3;\r\n  ghosts[3].name = 'Clyde';\r\n  ghosts[3].color = 'orange';\r\n  ghosts[3].colorCode = '#f9ba55';\r\n  ghosts[3].initialWaitingTimeInBox = 1900;\r\n\r\n  resetGhosts(ghosts);\r\n\r\n  return ghosts;\r\n};\r\n","import { observable } from 'mobx';\r\nimport { getPillsMatrix, TileId } from './MazeData';\r\n\r\nexport class Maze {\r\n  @observable\r\n  pills: TileId[][] = getPillsMatrix();\r\n}\r\n","/* eslint-disable @typescript-eslint/ban-types */\r\n\r\nimport { Machine, interpret, State } from 'xstate';\r\n\r\nexport const INITIAL_PACMAN_STATE = 'eating';\r\n\r\ninterface EventHandler {\r\n  onChasing(): void;\r\n  onDead(): void;\r\n}\r\n\r\ntype PacManContext = {};\r\n\r\ninterface PacManStateSchema {\r\n  states: {\r\n    eating: {};\r\n    chasing: {};\r\n    dead: {};\r\n  };\r\n}\r\n\r\nexport type PacManEventType =\r\n  | 'ENERGIZER_EATEN'\r\n  | 'ENERGIZER_TIMED_OUT'\r\n  | 'COLLISION_WITH_GHOST'\r\n  | 'REVIVED';\r\n\r\ntype PacManEvent = { type: PacManEventType };\r\n\r\nexport type PacManState = State<\r\n  PacManContext,\r\n  PacManEvent,\r\n  PacManStateSchema,\r\n  any\r\n>;\r\n\r\nconst PacManStateChart = Machine<PacManContext, PacManStateSchema, PacManEvent>(\r\n  {\r\n    id: 'pac-man',\r\n    initial: INITIAL_PACMAN_STATE,\r\n    states: {\r\n      eating: {\r\n        on: {\r\n          ENERGIZER_EATEN: 'chasing',\r\n          COLLISION_WITH_GHOST: 'dead',\r\n        },\r\n      },\r\n      chasing: {\r\n        entry: 'onChasing',\r\n        on: {\r\n          ENERGIZER_TIMED_OUT: 'eating',\r\n        },\r\n      },\r\n      dead: {\r\n        entry: 'onDead',\r\n        on: {\r\n          REVIVED: 'eating',\r\n        },\r\n      },\r\n    },\r\n  }\r\n);\r\n\r\nexport const makePacManStateChart = (eventHandler: EventHandler) => {\r\n  const extended = PacManStateChart.withConfig({\r\n    actions: {\r\n      onChasing: eventHandler.onChasing,\r\n      onDead: eventHandler.onDead,\r\n    },\r\n  });\r\n  const stateChart = interpret(extended);\r\n  return stateChart;\r\n};\r\n","import { observable, action, computed } from 'mobx';\r\n\r\nimport { Direction, MilliSeconds } from './Types';\r\nimport {\r\n  tileFromScreen,\r\n  screenFromTile,\r\n  TileCoordinates,\r\n  ScreenCoordinates,\r\n  assertValidTileCoordinates,\r\n} from './Coordinates';\r\nimport {\r\n  makePacManStateChart,\r\n  PacManEventType,\r\n  INITIAL_PACMAN_STATE,\r\n  PacManState,\r\n} from './PacManStateChart';\r\nimport { Game } from './Game';\r\nimport { StateValue } from 'xstate';\r\n\r\nexport class PacMan {\r\n  constructor(game: Game) {\r\n    this.game = game;\r\n\r\n    this.stateChart.onTransition(this.handleTransition);\r\n    this.stateChart.start();\r\n  }\r\n\r\n  @action.bound\r\n  handleTransition(state: PacManState) {\r\n    if (!state.changed) {\r\n      return;\r\n    }\r\n    this.stateChartState = state;\r\n  }\r\n\r\n  game: Game;\r\n\r\n  stateChart = makePacManStateChart({\r\n    onChasing: this.onChasing,\r\n    onDead: this.onDead,\r\n  });\r\n\r\n  @observable.ref\r\n  stateChartState: PacManState = this.stateChart.state;\r\n\r\n  @action.bound\r\n  onChasing() {\r\n    this.game.energizerTimer.start();\r\n  }\r\n\r\n  @action.bound\r\n  onDead() {\r\n    this.diedAtTimestamp = this.game.timestamp;\r\n  }\r\n\r\n  @computed\r\n  get dead(): boolean {\r\n    return this.stateChartState.matches('dead');\r\n  }\r\n\r\n  @computed\r\n  get state(): StateValue {\r\n    return this.stateChartState.value;\r\n  }\r\n\r\n  send(event: PacManEventType) {\r\n    this.stateChart.send(event);\r\n  }\r\n\r\n  @computed\r\n  get alive() {\r\n    return !this.dead;\r\n  }\r\n\r\n  @observable\r\n  screenCoordinates: ScreenCoordinates = screenFromTile({ x: 1, y: 1 });\r\n\r\n  @action\r\n  setTileCoordinates(tile: TileCoordinates) {\r\n    assertValidTileCoordinates(tile);\r\n    this.screenCoordinates = screenFromTile(tile);\r\n  }\r\n\r\n  @computed\r\n  get tileCoordinates(): TileCoordinates {\r\n    return tileFromScreen(this.screenCoordinates);\r\n  }\r\n\r\n  @observable\r\n  diedAtTimestamp: MilliSeconds = -1;\r\n\r\n  @computed\r\n  get timeSinceDeath(): MilliSeconds {\r\n    if (this.alive) {\r\n      return 0;\r\n    }\r\n    return this.game.timestamp - this.diedAtTimestamp;\r\n  }\r\n\r\n  @observable\r\n  extraLivesLeft = 2;\r\n\r\n  @observable\r\n  direction: Direction = 'RIGHT';\r\n  nextDirection: Direction = 'RIGHT';\r\n}\r\n\r\nexport const resetPacMan = (pacMan: PacMan) => {\r\n  pacMan.diedAtTimestamp = -1;\r\n  pacMan.stateChart.state.value = INITIAL_PACMAN_STATE;\r\n  pacMan.setTileCoordinates({ x: 14, y: 23 });\r\n  pacMan.nextDirection = 'LEFT';\r\n  pacMan.direction = 'LEFT';\r\n};\r\n","import { action, computed, observable } from 'mobx';\r\nimport { Ghost } from './Ghost';\r\nimport { makeGhosts, resetGhosts } from './makeGhosts';\r\nimport { Maze } from './Maze';\r\nimport { PacMan, resetPacMan } from './PacMan';\r\nimport { MilliSeconds, PixelsPerFrame } from './Types';\r\nimport { Store } from './Store';\r\nimport { TimeoutTimer } from './TimeoutTimer';\r\n\r\nexport const DEFAULT_SPEED = 2;\r\n\r\nconst ENERGIZER_DURATION: MilliSeconds = 5000;\r\n\r\nexport class Game {\r\n  constructor(store: Store) {\r\n    this.store = store;\r\n    this.pacMan = new PacMan(this);\r\n    this.ghosts = makeGhosts(this);\r\n  }\r\n\r\n  store: Store;\r\n\r\n  //** The timestamp we got from requestAnimationFrame().\r\n  @observable\r\n  externalTimeStamp: MilliSeconds | null = null;\r\n\r\n  @observable\r\n  timestamp: MilliSeconds = 0;\r\n\r\n  @observable\r\n  lastFrameLength: MilliSeconds = 17;\r\n\r\n  @observable\r\n  frameCount = 0;\r\n\r\n  @observable\r\n  gamePaused = false;\r\n\r\n  speed: PixelsPerFrame = DEFAULT_SPEED;\r\n\r\n  ghosts: Ghost[];\r\n\r\n  pacMan: PacMan;\r\n\r\n  @observable\r\n  score = 0;\r\n\r\n  @observable\r\n  killedGhosts = 0;\r\n\r\n  maze = new Maze();\r\n\r\n  @action.bound\r\n  revivePacMan() {\r\n    this.pacMan.send('REVIVED');\r\n    this.timestamp = 0;\r\n    resetPacMan(this.pacMan);\r\n    resetGhosts(this.ghosts);\r\n  }\r\n\r\n  @computed\r\n  get gameOver(): boolean {\r\n    const pacMan = this.pacMan;\r\n    return pacMan.dead && pacMan.extraLivesLeft === 0;\r\n  }\r\n\r\n  energizerTimer = new TimeoutTimer(ENERGIZER_DURATION, () => {\r\n    this.handleEnergizerTimedOut();\r\n  });\r\n\r\n  @action\r\n  handleEnergizerTimedOut() {\r\n    this.pacMan.send('ENERGIZER_TIMED_OUT');\r\n    for (const ghost of this.ghosts) {\r\n      ghost.send('ENERGIZER_TIMED_OUT');\r\n    }\r\n  }\r\n\r\n  readyGameForPlay() {\r\n    resetPacMan(this.pacMan);\r\n  }\r\n}\r\n","import { observable } from 'mobx';\r\nimport { Store } from './Store';\r\nimport { GhostViewOptions } from './GhostViewOptions';\r\nimport { PacManViewOptions } from '../pages/GamePage/components/PacManViewOptions';\r\nimport { GameViewOptions } from './GameViewOptions';\r\n\r\nexport class DebugState {\r\n  constructor(store: Store) {\r\n    this.store = store;\r\n  }\r\n\r\n  store: Store;\r\n\r\n  @observable\r\n  gameViewOptions: GameViewOptions = {\r\n    hitBox: false,\r\n  };\r\n\r\n  @observable\r\n  ghostViewOptions: GhostViewOptions = {\r\n    target: false,\r\n    wayPoints: false,\r\n  };\r\n\r\n  @observable\r\n  pacManViewOptions: PacManViewOptions = {\r\n    somePlaceholder: false,\r\n  };\r\n}\r\n","import { observable, action } from 'mobx';\r\nimport { Game } from './Game';\r\nimport { DebugState } from './DebugState';\r\n\r\nexport class Store {\r\n  @observable\r\n  game: Game = new Game(this);\r\n\r\n  debugState = new DebugState(this);\r\n\r\n  @action.bound\r\n  resetGame() {\r\n    this.game = new Game(this);\r\n    this.game.readyGameForPlay();\r\n  }\r\n}\r\n","import React, { FC, ComponentType } from 'react';\r\nimport 'antd/dist/antd.compact.css';\r\n\r\nimport './GlobalStyles.css';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport { Routes } from './Routes';\r\nimport { AppMenu } from './components/AppMenu';\r\nimport { Store } from './model/Store';\r\nimport { StoreProvider } from './components/StoreContext';\r\n\r\nconst App: FC<{ store?: Store; Router?: ComponentType }> = ({\r\n  store = new Store(),\r\n  Router = BrowserRouter,\r\n}) => {\r\n  return (\r\n    <StoreProvider value={store}>\r\n      <Router>\r\n        <div className=\"App\">\r\n          <AppMenu />\r\n          <Routes />\r\n        </div>\r\n      </Router>\r\n    </StoreProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\n// https://github.com/mobxjs/mobx-react-lite/tree/v2.0.5#observer-batching\r\nimport 'mobx-react-lite/batchingForReactDom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}